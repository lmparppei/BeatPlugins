<!-- ================================================== -->
<!--      THIS IS ALL THE HARD-CODED HTML WE GET:       -->
<!-- ================================================== -->


<div id="debug" class="debugWindow" style="display: none"></div>
<div id="flexiContainer" class=""></div> 
<div id="cover" class="blurWindow" style="display: none" onclick="closeNewMenu(); toggleTrackingContainer(true); storeAndClosePrintbox(false)"></div>

<div id="buttonRow">
<div id="helpButton" class="bottomButton" onclick="mylog('clicked settingsButton'); toggleNewMenu('settingsMenu')"></div>
<div id="printButton" class="bottomButton" onclick="mylog('clicked exportButton'); toggleNewMenu('exportMenu')"></div>
<!-- <div id="indexCardSizeButton" class="bottomButton"><div id="indexCardPlus" class="roundButton">&#x25B2;</div><div id="indexCardMinus" class="roundButton">&#x25BC;</div></div> -->
<div id="indexCardButton" class="bottomButton" onclick="mylog('clicked indexCardButton'); toggleNewMenu('indexCardMenu')"></div>
<div id="showStuffButton" class="bottomButton" onclick="mylog('clicked stuffButton'); toggleNewMenu('showStuffMenu')"></div>
<div id="notesButton" class="bottomButton" onclick="mylog('clicked notesButton'); toggleNewMenu('notesMenu')"></div>
<div id="characterButton" class="bottomButton" onclick="mylog('clicked TrackingButton'); toggleNewMenu('trackingMenu')"></div>
<div id="zoomButton" class="bottomButton" onclick="mylog('clicked zoomButton'); toggleNewMenu('zoomMenu')"></div>
<!--div id="speedReport" class="bottomButton" onclick="toggleHelpContainer()">&#8984;</div-->
<!-- <div id="speedometer"></div> -->
</div>
<div id="notepanel" class=""></div>

<!-- ================================================== -->
<!--      HERE ENDS THE HTML PART, JAVASCRIPT BELOW     -->
<!-- ================================================== -->

<script>

//@note all the buttons are here

// $id("flexiContainer").ondblclick = function(event){
document.addEventListener("dblclick", function(event){
	event.preventDefault()
	event.stopPropagation()
	mylog(event)			
	editContent(event)
})

$id("flexiContainer").ondragstart = function(event){onDragStart(event)}
$id("flexiContainer").ondragend = function(event){onDragEnd(event)}
$id("flexiContainer").ondragenter = function(event){onDragEnter(event)}
$id("flexiContainer").ondragleave = function(event){onDragLeave(event)}
$id("flexiContainer").ondragover = function(event){onDragOver(event)}
$id("flexiContainer").ondrop = function(event){onDrop(event)}
$id("flexiContainer").classList.add("positionRelative")

document.getElementById("indexCardButton").innerHTML = outlineIcon
document.getElementById("characterButton").innerHTML = funnelIcon + `<div id="selectedCharacterName"></div>`
document.getElementById("showStuffButton").innerHTML = showIcon
document.getElementById("helpButton").innerHTML = gearIcon
document.getElementById("printButton").innerHTML = printerIcon
document.getElementById("notesButton").innerHTML = noteIcon
document.getElementById("zoomButton").innerHTML = zoomIcon


// GLOBAL UI VARIABLES

//# HEADER

let smallTypeTimer //= null; //setting initial timer to avoid errors	
let fullTypeTimer //= null;
var debugContainerVisibility=0;
var settingsContainerVisibility = 0;
var trackingContainerVisibility = 0;
var helpContainerVisibility = 0;
var notesAreDisplayed = false;
var markersAreDisplayed = false;
var synopsisAreDisplayed = false;
var beatsAreDisplayed = false;
var scenesAreHidden = false;
var oneColumnOutline;
var indexCardMode = false;
var currentZoomLevel;

var debugContainer = document.getElementById('debug');
var settingsContainer = document.getElementById('settings');
var trackingContainer = document.getElementById('tracking');
var helpContainer = document.getElementById('helpWindow');
var coverContainer = document.getElementById('cover');
var theRoot = document.querySelector(':root');
var colorScheme
var blockOrNone = ['block', 'none'];
var flexOrInLineBlock = ['flex', 'inline-block']

var classListArray = []

var contextMenuIsOpen = false
var weAreChangingColors = false

var logArray=[]

// GLOBAL DEFAULT VARIABLES

var areScenesProportional, whatAreSceneLengths, whatAreSceneNumbers, whatArePageNumbers, isRealTimeOn
var warningsAreOn
var theDocumentsWidth, theDocumentsHeight, theWindowsPositionX, theWindowsPositionY
	

// GLOBAL DOCUMENT-RELATED VARIABLES

var outline, pages
var heightFactor = 10 //initial value if all else fails

var currentSectionDepth;
var previousSectionDepth;
var lastIndexOfScene;
var currentLine;

var lengthOfScene = [];
var lengthOfSceneInEights = [];
var outlineElementNumber
var actNumber, endElement
var location, length 

var omittedNumber

var firstLineThatIsNoSynopsis = 0
var selectedNote = -1
var previouslyHovered

var limitWindowWidth = function(){

	// if (window.innerWidth < 380){
	// 	Beat.call("Beat.custom.limitWidth()")
	// 	return
	// }

	someoneResizedTheWindow()
}

var someoneResizedTheWindow = debounce(function() {

	// if (window.innerWidth < 380){
	// 	Beat.call("Beat.custom.limitWidth()")
	// 	return
	// }

	theRoot.style.setProperty('--theDocumentWidth', window.innerWidth)
	theRoot.style.setProperty('--theDocumentHeight', window.innerHeight)
	saveCurrentState()
	recalculateHeights("from someoneResizedTheWindow")
	if(beatsAreDisplayed){toggleDisplayBeats(); toggleDisplayBeats()}
}, 150);


//	EVENTLISTENER ON LOAD: FETCH DATA FROM PLUGIN, THEN BUILD THE COMPLETE OUTLINE:

window.addEventListener('load', function () {
	setAllEventlisteners()
	completeRun()
	mylog("now to get defaults")
	getDefaults() 
	
	//Beat.call("Beat.custom.setFrame("+ theWindowsPositionX + " ," + theWindowsPositionY + "," + theDocumentsWidth + "," + theDocumentsHeight + ")")

})

// var slugSizeObserver = new ResizeObserver(entries => {
// 	hideSlugFor(entries);
// })


//	EVENTLISTENERS FOR keypresses and such
function setAllEventlisteners(){

	window.onerror = function(message, source, lineno, colno, error) {
		// mylog("===== ERROR =====", false, true)
		mylog("===== ERROR =====", true)
		}

	document.addEventListener("keydown", checkWhatKeyGotPressed);
	document.addEventListener("keyup", checkWhatKeyWasReleased);
	document.addEventListener("mouseup", function(){somethingWasClicked()});
	// window.addEventListener("resize", limitWindowWidth);
	window.onresize = limitWindowWidth;
	window.addEventListener("focus", function () {
		if(isRealTimeOn == 1){return}
		document.getElementById('outOfSyncDiv').style.display = "none";
		// document.getElementById('flexiContainer').classList.remove("wait")
		completeRun()//should provide loc and len here!	
		});
	window.addEventListener("blur", function () {
		deselectAllElements()
		closeContextMenu()
		saveCurrentState()
		if (document.querySelector(".sceneTitlePopup")){document.querySelector(".sceneTitlePopup").remove()}
		});	
	document.addEventListener("mouseover", hover)
	document.addEventListener("mouseleave", unhover) //was moouseout
}

function hover() {
	
	mylog("HOVERING " + event.target.classList)

	let element = event.target

	// $id("buttonRow").innerHTML = element.classList

	//Gatekeeping
		if (weAreCurrentlyEditingText){
			return
		}
		if (JSON.stringify(element.closest(".scene, .section")?.id) == previouslyHovered
			|| element.id == "hiddenSceneTitlePopup"){
				mylog("returning bc previously hovered: " + previouslyHovered)
				return
		}

	//Actual stuff before going to unhover: 
	//NOTEPANEL...
		if(element.classList.contains("notepanelNote") || element.classList.contains("notepanelReview")){
			panelNoteIsHovered(element)
			return
		}
	//BEATS...
		if(element.classList.contains("beat")){
			beatIsHovered(element)
			return
		}
		if(element.classList.contains("review")){
			highlightReviewInPanel(element)
			return
		}
	//markers...
		if(element.classList.contains("marker")){
			return
		}

	unhover()

	//Popping up scene name for small scenes
		if (element.closest(".scene")?.classList.contains("hideSlugIfSmall") && !altIsBeingPressed){
			hiddenSlugPopup(element)
		}

	
	//on hover, we always go to insert addButton and make the gatekeeping there.
	currentlyHoveredElement = element // keeps it in mind for ALT-pressing
	mylog("sending to addbutton...")

		// if (altIsBeingPressed){
			
		// }

		try{
			insertAddButton(element)
		}catch(err){
			mylog("CAUGHT an ERROR trying to ADD or PROMOTE BUTTON" + err.name + err.message)
		}
	
}

function hiddenSlugPopup(element) {

	previouslyHovered = JSON.stringify(element.closest(".scene")?.id)
	currentlyHoveredElement = false

	let x = parseInt(JSON.stringify(event.clientX))
	let y = parseInt(JSON.stringify(element.closest(".scene").getBoundingClientRect().top))
	let width = parseInt(JSON.stringify(element.closest(".scene").getBoundingClientRect().width)) + 20
	let color = window.getComputedStyle(element.closest(".scene")).getPropertyValue('background-color')

	if (x + width > window.innerWidth - 40){
		x = x - width + 20
	}

	let hiddenSceneTitlePopupDiv = document.createElement("div")
		hiddenSceneTitlePopupDiv.id = "hiddenSceneTitlePopup"
		hiddenSceneTitlePopupDiv.innerHTML = element.innerHTML
		hiddenSceneTitlePopupDiv.classList.add("clickThru")
		hiddenSceneTitlePopupDiv.classList.add("sceneTitlePopup")
		hiddenSceneTitlePopupDiv.style.left = (x + 10) + "px"
		hiddenSceneTitlePopupDiv.style.top = (y - 22) + "px"
		hiddenSceneTitlePopupDiv.style.maxWidth = width + "px"
		hiddenSceneTitlePopupDiv.style.backgroundColor = color
		
		flexiContainer.appendChild(hiddenSceneTitlePopupDiv)

	clearTimeout(popupTimer)
	let elementToGivePopup = $id('hiddenSceneTitlePopup')
	popupTimer = setTimeout(function(){
		elementToGivePopup.classList.add('revealPopup')
		},1200
	)
}

function unhover(){

	mylog()

	let element = event.target
	let relatedElement = event.relatedTarget

	if(relatedElement && ([...relatedElement.classList].includes("notepanelNote") || [...relatedElement.classList].includes("notepanelReview"))){
		panelNoteIsUnhovered(relatedElement)
	}

	if(relatedElement && (relatedElement.classList.contains("review"))){
		highlightReviewInPanel()
	}
	
	previouslyHovered = false
	
	let elements = document.querySelectorAll(".sceneTitlePopup")
	for (i = elements.length - 1; i>-1; i--) {
		elements[i].remove()
	}
}

// MARK: - ========== UPDATING THE TIMELINE ==========

function __________TIMELINE (){}
		
function startFullUpdate(delayTime) { //not getting loc and len from outlinechange anyway so removed now!
	
	// mylog("FULL CALLED! Location: "  + location + ", length: " + length, true, true)
	mylog("FULL CALLED! Location: "  + location + ", length: " + length)
	actualChangesToScriptInProgress = false //this is for the errorhandler to know what was happening

	//document.getElementById('outOfSyncDiv').classList.add('animate');
	$id('outOfSyncDiv').style.display = 'block'
	flexiContainer.classList.add("wait")
	
	if (isRealTimeOn == 0 && weAreChangingColors == false){
		document.getElementById('outOfSyncMessage').innerHTML = "Outline out of sync. Click anywhere to refresh.";
		document.getElementById("outOfSyncDiv").style.animation = "none";
		//document.getElementById("outOfSyncDiv").style.display = "block";

		if(document.getElementById("youAreHere")){document.getElementById("youAreHere").remove()}

		return
	}

		document.getElementById('outOfSyncMessage').innerHTML = "";
		
		clearTimeout(fullTypeTimer)
		fullTypeTimer = false

		let timeToWait = weAreChangingColors ? 0 : 1000
		let callback = function(){
			mylog("--------------------- full update fires NOW ---------------------------")
			rememberCardState()
			// $("#speedometer").classList.toggle("locateme")
			// Beat.call("Beat.custom.updateEntireOutline(" + location + "," + length + "," + (outline.length||'false') + ")")	
			Beat.call("Beat.custom.updateEntireOutline(false, false," + (outline.length||'false') + ")")	
			
		}
		fullTypeTimer = setTimeout(
			callback, delayTime || timeToWait // 1000 
			)
			
	// 	document.getElementById('outOfSyncMessage').innerHTML = "Outline out of sync. Click anywhere to refresh.";
	// 	document.getElementById("outOfSyncDiv").style.animation = "none";
	// 	document.getElementById("outOfSyncDiv").style.display = "block";

	// 	if(document.getElementById("youAreHere")){document.getElementById("youAreHere").remove()}
}

function updateCaller(){
	Beat.call("Beat.custom.updateEntireOutline(" + location + "," + length + "," + (outline.length||'false') + ")")	
}

function startSmallUpdate(location, length, delayTime, elementType) {

	mylog('SMALL CALLED! and fullTypeTimer is ' + fullTypeTimer)

	//it may be that this never ever fires, but hey. 
	if(fullTypeTimer > 0){
		mylog("we're already queueing a full one, so trying to abort")
		return
	}

	if(elementType && elementType != "Heading"){
		mylog(" ")
		mylog("BUT! Now sending SMALL ==> FULL because seems like we're writing in orphan text")
		mylog(" ")

		startFullUpdate()
		return
	}
		
	if(outline.length < 1){
		displayEmptyScreenMessage()
		return}

	if (isRealTimeOn == 1 || weAreChangingColors == true){	

		clearTimeout(smallTypeTimer);

		let timeToWait = weAreChangingColors ? 0 : 1000

		let callback = function(){
				rememberCardState()
				Beat.call("Beat.custom.updateOnlyOneScene(" + location + "," + length + ")")
				}
		smallTypeTimer = setTimeout(
			callback, delayTime || timeToWait
			); 		
		}
	else
		{
		document.getElementById('outOfSyncMessage').innerHTML = "Outline out of sync. Click anywhere to refresh.";
		document.getElementById("outOfSyncDiv").style.animation = "none";
		document.getElementById("outOfSyncDiv").style.display = "block";

		if(document.getElementById("youAreHere")){document.getElementById("youAreHere").remove()}
		}
}

function completeRun(location, length){ //Called AT STARTUP and (when non-realtime) AT FOCUS
	mylog()
	
	weAreCurrentlyEditingText = false
	weAreChangingColors = true //testing if this speeds up first draw!

	Beat.call("Beat.custom.updateEntireOutline(" + location + "," + length + ")")
}

function updateEverything(json, location, length, pagesAsString, absoluteLength, pageBreakPositions, frontmatter) {
	mylog(json)

	if(pagesAsString) {pages = pagesAsString} //unique to everything
	if(pageBreakPositions) {pageBreaks = pageBreakPositions} // same...

	outline = JSON.parse(json)
	absoluteTextLength = absoluteLength //making it global...
	frontMatter = frontmatter
	addSceneEnds()

	if(outline.length < 1){displayEmptyScreenMessage(); return}

	recalculatePages()
	divMaker(location, true)
	mylog("back after divmaker")
	
	if (characterMenuList.selectedIndex != -1){

		updateFilter("") //this call is unnecessary for functionality, but works to eliminate blinkage.
		for (i=0; i<outline.length; i++) { //loop in "everything", single line in other
			Beat.call("Beat.custom.reevaluateCharactersForScene(" + i + "," + (i == outline.length-1) + ")") //will send false except last time
		}
	}
	if (notesAreDisplayed || markersAreDisplayed || beatsAreDisplayed || $id("notepanel")){
		collectNotes("updateEverything")
	}
	if (reviewsAreDisplayed){collectReviews()}

	collectRevisionIndices()

	//the following clears the UPDATE animation (should only be visible on slower machines)
	document.getElementById('outOfSyncDiv').style.display = 'none'
	document.getElementById('outOfSyncDiv').classList.remove('animate')
	document.getElementById('flexiContainer').classList.remove("wait")

	recalculateHeights("from UpdateEverything") // but this is also called from YouAreHere so why twice?
												// now put back to see if it removes blinkage
												
	//recallCardState() //same thing: Since we always make a small run, let this happen from there only?
	youAreHere(location, length) 

	if(weAreCurrentlyEditingText){ //} = false // this is if update takes place when live editing outline text
		exitEdit()
	}
	weAreChangingColors = false


	mylog("end of chain (full)")
	//NOTE: here ends the chain of functions based on needFullUpdate, now returning home
}

function updateOneScene(json, scene, pagesForChangedScene, location, length, absoluteLength, pageBreakForChangedScene, frontmatter){
	mylog()
	mylog(json.length + ", location passed is" + location)

	outline = JSON.parse(json)
	absoluteTextLength = absoluteLength //making it global...
	frontMatter = frontmatter
	addSceneEnds()
	
	pages[scene] = pagesForChangedScene // Note: scene here now means outline item
	pageBreaks[scene] = pageBreakForChangedScene
	
	if(outline.length < 1){displayEmptyScreenMessage(); return}
	
	recalculatePages()
	divMaker(location, false)
	mylog("back after divmaker (single)")
		
	if (characterMenuList.selectedIndex != -1){
	
		updateFilter() //again: unnecessary for functionality, but just to eliminate blinkage.	
		Beat.call("Beat.custom.reevaluateCharactersForScene(" + scene + "," + "true" + ")")
	}
	if (notesAreDisplayed || markersAreDisplayed || beatsAreDisplayed || $id("notepanel")){
		collectNotes("updateOneScene")
	}

	if (reviewsAreDisplayed){collectReviews()}

	collectRevisionIndices()

	//the following clears the UPDATE animation (should only be visible on slower machines)
	document.getElementById('outOfSyncDiv').style.display = 'none'
	document.getElementById('outOfSyncDiv').classList.remove('animate')
	document.getElementById('flexiContainer').classList.remove("wait")

	fullTypeTimer = false //only in small update?

	//recalculateHeights("from updateOneSceen")  // but this is ALSO called from youAreHere!
	
	mylog("before recall in Small -- " + cardStateForScenes)
	recallCardState() //this was the enabled one
	youAreHere(location, length) 
	
	if(weAreCurrentlyEditingText){ //} = false // this is if update takes place when live editing outline text
		exitEdit()
	}

	weAreChangingColors = false
    Beat.call(`
		Beat.onTextChangeDisabled = false
		Beat.onOutlineChangeDisabled = false
		Beat.onSelectionChangeDisabled = false
	`)
		
	//NOTE: here ends the chain of functions based on needSmallUpdate, now returning home
	mylog("end of chain (one scene)")
}

function addSceneEnds(){

	mylog()

	function hierarchy(obj){
		let level = false
		if (obj.typeAsString == "Section"){level = Number(obj.sectionDepth)}
		if (obj.typeAsString == "Heading"){level = 100}
		if (obj.typeAsString == "Synopse"){level = 1000}
		return level 
	}

	//Insert SceneEnd value, which ends not at next arbitrary outline element, but one which is the same or higher! 2022-01-11
	for (let i = 0; i < outline.length; i++){

		let nextSameLevelObject = i + 1

		while ((nextSameLevelObject < outline.length) && (hierarchy({...outline[nextSameLevelObject]}) > hierarchy({...outline[i]}))){
			//if(!outline[nextSameLevelObject + 1]){break}
			nextSameLevelObject++
		}
		
		outline[i].sceneEnd = (outline[nextSameLevelObject]) ? 
			outline[nextSameLevelObject].sceneStart - 1 : 
			absoluteTextLength
	}
}


function divMaker(location, fullupdate){

	mylog()
	mylog("AT START OF DIVMAKER, we have this location: " + location)

	let startTime = new Date()

	let start = 0
	let end = outline.length

	let newFlexi = document.createElement("div")
	let currentAct = 0
	let actLengths = []
	let actIndex = []
	let alternatePageNumber = 0

	let lowerLevelNum = -1

	//Make scencards expanded or collapsed as before
		if(outlineBeforeUpdate && outline.length != outlineBeforeUpdate.length){
			makeCardStateEqual()
		}

	for (num = start; num < end; num ++) {

		currentItem = outline[num]

		//first creating a FAUX ACT if doc does not start with a level 1 section
			if (num == 0 && (outline[num].typeAsString != "Section" || outline[num].sectionDepth > 1 || outline[num].sceneStart > frontMatter)) {

				actLengths[currentAct] = 0
				currentAct ++
							
				let sectionDiv = document.createElement("div")
					sectionDiv.id = "-1"
					sectionDiv.classList.add("faux")
					sectionDiv.classList.add("section")
					sectionDiv.classList.add("level1")
					sectionDiv.classList.add("isExpanded")
					// sectionDiv.dataset.line = currentItem.sceneStart
					sectionDiv.dataset.line = 0
					// sectionDiv.dataset.lineEnd = currentItem.sceneStart + currentItem.line.range.length
					sectionDiv.dataset.lineEnd = Math.max(currentItem.sceneStart - 1, 0)
					sectionDiv.dataset.lengthOfScene = currentItem.numberOfPages
					sectionDiv.dataset.inAct = "0"

				let sectionSynConDiv = document.createElement("div")
					sectionSynConDiv.id = "synopsisFor-1"
					sectionSynConDiv.classList.add("synopsiscontainer")
					// sectionSynConDiv.dataset.line = currentItem.sceneStart
					sectionSynConDiv.dataset.line = 0
					
					sectionDiv.appendChild(sectionSynConDiv)
					newFlexi.appendChild(sectionDiv)

					let actlengthDiv = document.createElement("div")
						actlengthDiv.classList.add("showActLength")
						sectionDiv.appendChild(actlengthDiv)
					
				}
		
		let color
		switch(currentItem.typeAsString){

			case "Section":

				let parentSection = newFlexi

				if(currentItem.sectionDepth == 1){
					// actLengths[currentAct] = alternatePageNumber
					actLengths[currentAct] = currentItem.startsOnPage

						let checkback = 1 // check for preceding line break, looking past synopsis/hidden scenes
						while(outline[num - checkback] && (outline[num - checkback].typeAsString == "Synopse" || outline[num - checkback].omitted)){
							checkback ++
						}
						if (pageBreaks[num - checkback]) actLengths[currentAct] = currentItem.startsOnPage - 1 //correct page number if forced page break

					actIndex[currentAct] = currentItem.sceneStart
					currentAct ++

					
				}

				if(currentItem.sectionDepth > 1)lowerLevelNum ++

				for (let i = num; i > -1; i--){

					if (outline[i].typeAsString == "Section" && outline[i].sectionDepth < currentItem.sectionDepth){

						let allParents = newFlexi.querySelectorAll(".level" + outline[i].sectionDepth)
						parentSection = allParents[allParents.length - 1]

						break
					}
				}
				//below: when there is no initial act, put corresponding stuff inside faux act
				if(parentSection == newFlexi && outline[num].sectionDepth > 1){
					parentSection = newFlexi.querySelector(".faux")
				}

				
			
				let sectionDiv = document.createElement("div")
					sectionDiv.id = num.toString()
					sectionDiv.classList.add("section")
					sectionDiv.classList.add("level" + currentItem.sectionDepth)
					sectionDiv.dataset.line = currentItem.sceneStart
					sectionDiv.dataset.lineEnd = currentItem.sceneStart + currentItem.line.range.length
					sectionDiv.dataset.lengthOfScene = currentItem.numberOfPages
					sectionDiv.dataset.inAct = currentAct
					sectionDiv.draggable = true

					color = currentItem.color
					if (color.includes("]") || color.includes('[') || color.split(" ").length > 1){
						color = color.replace(/(\]|\[|\s).*/, "")
					}

					if(color){
						if (color.match(/(#[A-F, 0-9]{6})/i)){
							// sectionDiv.style.borderLeftColor = color
							sectionDiv.style.setProperty("--localColor", color)
						}else{
							sectionDiv.classList.add(color.toLowerCase())
							let localColor = getComputedStyle(document.documentElement).getPropertyValue(`--${color.toLowerCase()}`)
							sectionDiv.style.setProperty("--localColor", `hsl(var(--${color.toLowerCase()}))`)
						}
					}

					if (currentItem.stringForDisplay?.toLowerCase() == "boneyard"
						&&
						currentItem.sectionDepth == 1){
						sectionDiv.classList.add("boneyard")
						//should check that level = 1
					}

					if(outlineBeforeUpdate && outline.length == outlineBeforeUpdate.length){
						let isExpanded = cardStateForScenes[num]
						let collapsedSection = cardStateForSections[num]
						let isPinned = $id(num.toString())?.classList.contains("wider")
						if(isExpanded)sectionDiv.classList.add("isExpanded")
						if(collapsedSection && currentItem.sectionDepth > 1)sectionDiv.classList.add("collapsedSection")
						if(isPinned)sectionDiv.classList.add("wider")
					}

				let sectionheaderDiv = document.createElement("div")
					sectionheaderDiv.classList.add("section-heading")
					sectionheaderDiv.dataset.line = currentItem.sceneStart
					// if(color){
					// 	if (color.match(/(#[A-F, 0-9]{6})/i)){
					// 		sectionheaderDiv.style.backgroundColor = color
					// 	}else{
					// 		sectionheaderDiv.classList.add(color.toLowerCase())
					// 	}
					// }

					if(currentItem.sectionDepth > 1){
						let sectionarrowDiv = document.createElement("div")
							sectionarrowDiv.classList.add("sectionArrow")
							sectionheaderDiv.appendChild(sectionarrowDiv) 
					
					let pagenumberDiv = document.createElement("div")
						pagenumberDiv.classList.add("showSectionPageNumber")
						//pagenumberDiv.innerHTML = "Pg " + Math.max(Math.ceil(alternatePageNumber), 1) + "."
						pagenumberDiv.innerHTML = "Pg " + Math.max(Math.floor(currentItem.startsOnPage), 1) + "."

					sectionheaderDiv.appendChild(pagenumberDiv)
					}

					// if(loggingIsOn){sectionheaderDiv.innerHTML += currentItem.sceneStart + ", " + currentItem.sceneEnd + " -- "}
					// if(loggingIsOn && currentItem.sectionDepth > 1){sectionheaderDiv.innerHTML += (cardStateForSections[lowerLevelNum]? "" : "open, ") + "" + (cardStateForScenes[lowerLevelNum]? "show" : "") + " -- "}
					if(loggingIsOn && currentItem.sectionDepth > 1){sectionheaderDiv.innerHTML += "#" + outline.indexOf(currentItem)}
					sectionheaderDiv.innerHTML += currentItem.stringForDisplay.replace(/^#+/, "")
					if(currentItem.sectionDepth == 1)sectionheaderDiv.innerHTML += `<span class='widerButton'>${pinIcon}</span><span class='widerButtonOn'>${pinPushedIcon}</span>`


				let sectionSynConDiv = document.createElement("div")
					sectionSynConDiv.id = "synopsisContainerFor" + num
					sectionSynConDiv.classList.add("synopsiscontainer")
					sectionSynConDiv.classList.add("noAnimation")
					sectionSynConDiv.dataset.line = currentItem.sceneStart
					
					//sectionSynConDiv.style.backgroundColor = "#bbb"
					if(color){
						// if (color.match(/(#[A-F, 0-9]{6})/i)){
						// 	sectionSynConDiv.style.backgroundColor = color
						// }else{
						// 	sectionSynConDiv.style.backgroundColor = ""
						// 	sectionSynConDiv.classList.add(color.toLowerCase())
						// }
					}else if(currentItem.sectionDepth == 1){
						sectionSynConDiv.style.backgroundColor = "transparent"
					}

					if(currentItem.numberOfPages > 0){

						let orphanDiv = document.createElement("div")
							orphanDiv.classList.add("orphanText")
							orphanDiv.id = "orphanInside" + num
							orphanDiv.dataset.line = (currentItem.sceneStart)
							orphanDiv.dataset.lengthOfScene = currentItem.numberOfPages	

						//FINALLY, this *SHOULD* remove size-related blinkage?
						//if (areScenesProportional == 1){
						orphanDiv.style.height = `calc(${currentItem.numberOfPages}px * var(--heightFactor))`
						//}
						
						if(pageBreaks && pageBreaks[num]) addPageBreak(orphanDiv)
						if(pageDividers[num]) insertDividersIn(orphanDiv)
						
						sectionDiv.appendChild(sectionheaderDiv)
						sectionDiv.appendChild(orphanDiv)
						orphanDiv.appendChild(sectionSynConDiv)

					}else{

						sectionDiv.appendChild(sectionheaderDiv)
						sectionDiv.appendChild(sectionSynConDiv)
					}

				// if(pageDividers[num]) {insertDividersIn(sectionDiv)} //adding page line for section too

				parentSection.appendChild(sectionDiv)

				if(currentItem.sectionDepth == 1){
					actlengthDiv = document.createElement("div")
					actlengthDiv.classList.add("showActLength")
					sectionDiv.appendChild(actlengthDiv)
				}

				if(currentItem.synopsis && currentItem.synopsis.length > 0){ //this will put synopsis into place (for sections) for version 1.977 and on
					for (let synopsisItem of currentItem.synopsis){
						synopsisMaker(synopsisItem)
					}
				}

				break

			case "Heading":

				let allSections = newFlexi.querySelectorAll(".section")
				let lastSection = allSections[allSections.length - 1]
				let lockedString = ""
				let sceneNumber = currentItem.sceneNumber
					if (currentItem.omitted == 1){sceneNumber = "OMITTED"}
				
				if (/(?:#)(.+)(?:#){1}\s*$/.test(currentItem.string)){
					lockedString =  "<a id='padlockIcon' class='padlockIcon' style='transition: none'>" + padlockIcon + "</a>"			 	
				}

				let sceneDiv = document.createElement("div")
					sceneDiv.id = num.toString()
					sceneDiv.classList.add("scene")
					if (currentItem.omitted == 1){
						sceneDiv.classList.add("isOmitted")
					}
					sceneDiv.dataset.line = currentItem.sceneStart
					sceneDiv.dataset.lineEnd = currentItem.sceneStart + currentItem.line.range.length
					sceneDiv.dataset.lengthOfScene = currentItem.numberOfPages
					sceneDiv.dataset.inAct = currentAct
					sceneDiv.draggable = true

					color = currentItem.color
					if (color.includes("]") || color.includes('[') || color.split(" ").length > 1){
						color = color.replace(/(\]|\[|\s).*/, "")
					}

					sceneDiv.style.setProperty("--localColor", "#ddd")
					if(color){
						if (color.match(/(#[A-F, 0-9]{6})/i)){
							// sceneDiv.style.backgroundColor = color
							sceneDiv.style.setProperty("--localColor", color)
						}else{
							sceneDiv.classList.add(color.toLowerCase())
							sceneDiv.style.setProperty("--localColor", `hsl(var(--${color.toLowerCase()}))`)
						}
					}
					//FINALLY, this *SHOULD* remove size-related blinkage?
					if (areScenesProportional == 1){
						sceneDiv.style.height = `calc(${currentItem.numberOfPages}px * var(--heightFactor))`
					}

					let ii = 1
					while(outline[num-ii] && outline[num - ii].typeAsString == "Synopse"){ii++}
					if(outline[num - ii] && outline[num - ii].typeAsString == "Section"){
						let scenearrowDiv = document.createElement("div")
							scenearrowDiv.classList.add("arrowForIndexCards")
							sceneDiv.appendChild(scenearrowDiv)
					}

				let sceneheadingDiv = document.createElement("div")
					sceneheadingDiv.classList.add("sceneheading")
					if ($id(num) && $id(num).classList.contains("hideSlugIfSmall")){
						sceneDiv.classList.add("hideSlugIfSmall")
					}
					sceneheadingDiv.dataset.line = currentItem.sceneStart
					if(color){
						sceneheadingDiv.classList.add(color.toLowerCase())
					}
				
				let sceneNumberSpan = document.createElement("SPAN")
					sceneNumberSpan.innerHTML = lockedString + sceneNumber + "&nbsp;"
					sceneNumberSpan.classList.add("showSceneNum")
					sceneheadingDiv.appendChild(sceneNumberSpan)
					
				let pageCountSpan = document.createElement("SPAN")
					pageCountSpan.innerHTML = numberIntoEights(currentItem.numberOfPages)
					pageCountSpan.classList.add("showSceneLength")
						if(pageBreaks && pageBreaks[num]){
							pageCountSpan.innerHTML = numberIntoEights(pageBreaks[num]) //shows ACTUAL length, without blankness
						}

					sceneheadingDiv.appendChild(pageCountSpan)

				let sceneSynConDiv = document.createElement("div")
					sceneSynConDiv.id = "synopsisFor" + num
					sceneSynConDiv.classList.add("synopsiscontainer")
					sceneSynConDiv.dataset.line = currentItem.sceneStart

					// if(color){
					// 	if (color.match(/(#[A-F, 0-9]{6})/i)){
					// 		sceneSynConDiv.style.backgroundColor = color
					// 	}else{
					// 		sceneSynConDiv.classList.add(color.toLowerCase())
					// 	}
					// // }else{
					// // 	sectionSynConDiv.style.backgroundColor = "#bbb"
					// }

				sceneheadingDiv.innerHTML += "<span class='slugtext'>"
					// if(loggingIsOn){sceneheadingDiv.innerHTML += currentItem.sceneStart + ", " + currentItem.sceneEnd + " -- "}
					if(loggingIsOn){sceneheadingDiv.innerHTML += "#" + outline.indexOf(currentItem)}
				//if(pageBreaks[num]) sceneheadingDiv.innerHTML += pageBreaks[num] + " ... "
				// sceneheadingDiv.innerHTML += "pg. " + currentItem.startsOnPage + " -- "
				sceneheadingDiv.innerHTML += currentItem.stringForDisplay.toUpperCase() + "</span>"
				sceneDiv.appendChild(sceneheadingDiv)
				sceneDiv.appendChild(sceneSynConDiv)

			if(pageBreaks && pageBreaks[num])addPageBreak(sceneDiv)

				function addPageBreak(whereToAdd){

					blankDiv = document.createElement("div")
					blankDiv.id = "blankPageFor" + num
					blankDiv.classList.add("blankPage")
					
					blankDiv.style.top = 100 * pageBreaks[num]/currentItem.numberOfPages + "%"
					blankDiv.style.height =  100.5 - (100 * pageBreaks[num]/currentItem.numberOfPages) + "%"
						let nextActualScene = 1
						while(outline[num + nextActualScene] && outline[num + nextActualScene].typeAsString == "Synopse"){nextActualScene ++}
					blankDiv.dataset.line = outline[num + nextActualScene]?.sceneStart - 4
					blankDiv.dataset.length = outline[num + nextActualScene]?.sceneStart - 1

					whereToAdd.appendChild(blankDiv)

				}

			if(pageDividers[num]) {insertDividersIn(sceneDiv)}

				function insertDividersIn(whereToAdd){

					for (let p = 0; p < pageDividers[num].length - (pageBreaks[num] ? 1 : 0); p++){

						let reduceFirstScene = newFlexi.querySelector(".scene, .orphan") ? 0 : 1 //or else first pg number is 2...
						let approxBreakPos = currentItem.sceneStart + ((currentItem.sceneEnd - currentItem.sceneStart) * pageDividers[num][p]/currentItem.numberOfPages) 

						let divider = document.createElement("div")
							divider.id = "divider" + num + "-" + p
							divider.classList.add("pageDivider")
							divider.innerHTML = Math.trunc(currentItem.startsOnPage + 1 + p - reduceFirstScene)
							// divider.dataset.line = currentItem.line.position
							divider.dataset.line = approxBreakPos

							divider.style.top = 100 * pageDividers[num][p]/currentItem.numberOfPages + "%"
							// divider.style.height = 100 / currentItem.numberOfPages + "%"

						whereToAdd.appendChild(divider)

					}
				}

				lastSection.appendChild(sceneDiv)

				if(currentItem.synopsis && currentItem.synopsis.length > 0){ //this will put synopsis into place (for scenes) for version 1.977 and on
					for (let synopsisItem of currentItem.synopsis){
						synopsisMaker(synopsisItem)
					}
				}

				break

			case "Synopse":

				synopsisMaker(currentItem) //this will put synopsis into place for versions pre 1.977

				function synopsisMaker(currentItem){

				let allContainers = newFlexi.querySelectorAll(".synopsiscontainer")
				let lastContainer = allContainers[allContainers.length - 1]

				let synopsisDiv = document.createElement("div")
					synopsisDiv.id = num
					let synopsisNumber = false
						if(outline[num].synopsis){ 
							synopsisNumber = outline[num].synopsis.indexOf(currentItem)
							synopsisDiv.dataset.synopsisNumber = synopsisNumber
							synopsisDiv.id = "s" + num + "_" + (('000'+synopsisNumber).slice(-3)) // synopsisNumber
						}
					synopsisDiv.innerHTML = currentItem.stringForDisplay //|| currentItem.string.replace(/^=/, "")
					synopsisDiv.classList.add("synopsis")
					synopsisDiv.dataset.sceneNumber = currentItem.sceneNumber //necessary?
					synopsisDiv.dataset.line = (synopsisNumber !== false) ? outline[num].synopsis[synopsisNumber].position : currentItem.sceneStart
					synopsisDiv.dataset.lineEnd = (synopsisNumber !== false) ? outline[num].synopsis[synopsisNumber].position + outline[num].synopsis[synopsisNumber].range.length : currentItem.sceneEnd
					synopsisDiv.draggable = true
					
					color = currentItem.color
						if (color.includes("]") || color.includes('[') || color.split(" ").length > 1){
							color = color.replace(/(\]|\[|\s).*/, "")
						}
						if(color){
							if (color.match(/(#[A-F, 0-9]{6})/i)){
								// synposisDiv.style.backgroundColor = color
								synopsisDiv.style.setProperty("--localSynopsisColor", color)
							}else{
								synopsisDiv.classList.add(color.toLowerCase())
								// synopsisDiv.dataset.color = color.toLowerCase()
								synopsisDiv.style.setProperty("--localSynopsisColor", `hsl(var(--${color.toLowerCase()}))`)
							}
						}
					if (currentItem.omitted || (synopsisNumber !== false && outline[num].synopsis[synopsisNumber].omitted)){
						synopsisDiv.classList.add("isOmitted")
					}

				lastContainer.appendChild(synopsisDiv)
				}
		} 

		if(currentItem.numberOfPages){alternatePageNumber += Number(currentItem.numberOfPages)}
		// if(currentItem.typeAsString == "Heading"){alternatePageNumber += 2/58}

	}

	//BONEYARD-check to disallow any boneyard that is not last act
		let allActs = newFlexi.querySelectorAll(".level1")
		for (i = 0; i < allActs.length - 1; i++){
				allActs[i].classList.remove("boneyard")
			}		
	
	$id("flexiContainer").innerHTML = newFlexi.innerHTML
		
	//re-enabled this because why not?
	if(indexCardMode || areScenesProportional != 1){
		recallCardState()
	}

	//actLengths.push(alternatePageNumber) // adding the last page number after the fact // previously made an alt number but why?
	//actLengths.push(currentItem.startsOnPage + currentItem.sceneLength) // adding the last page number after the fact
	actLengths.push(Math.floor(currentItem.startsOnPage + currentItem.numberOfPages)) // adding the last page number after the fact
	actIndex.push(currentItem.sceneEnd)  // index for last page number
	
	let allActPages = $$(".showActLength")
	for (let i = 0; i < allActPages.length; i++){
		allActPages[i].innerHTML = "Pg " + Math.trunc(actLengths[i + 1]) + "."
		allActPages[i].dataset.line = actIndex[i+1]
	}

	let endTime = new Date()

	//$id("printButton").innerHTML = (endTime - startTime)

	recalculateHeights()
	reevaluateColorContrast()

		//NEW: Let's try to map out any revision marks!
		// if(documentSetting.showRevisions)collectRevisionIndices()
}

function __________OUTLINE_GRAPHICS(){}

function reevaluateColorContrast(){

	mylog()

	if(!invertTextOnDark) return

	let redraw = $id("flexiContainer").getBoundingClientRect() // trigger redraw to paint all elements correctly first

	allItems = $$(".sceneheading")

	mylog("1")
	
	for (let item of allItems){
		let styles = window.getComputedStyle(item.parentNode)
		let $rgb = makeRGB(styles.backgroundColor)
		$rgb = $rgb.replace("rgb(", "").replace(")", "").split(",")
		// if ($rgb.length != 3) {continue}
		let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
		item.style.color = (blackOrWhite > 128) ? "black" : "white"
		item.style.fill = (blackOrWhite > 128) ? "black" : "white"
	}
	
	allItems = $$(".section-heading:not(.level1 > .section-heading)")
	
	mylog("2")
	
	for (let item of allItems){
		let styles = window.getComputedStyle(item)
		let $rgb = makeRGB(styles.backgroundColor)
		$rgb = $rgb.replace("rgb(", "").replace(")", "").split(",")
		// if ($rgb.length != 3) {continue}
		let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
		item.style.color = (blackOrWhite > 128) ? "black" : "white"
	}
	
	allItems = $$(".synopsis")
	
	mylog("3")
	
	for (let item of allItems){
		let styles = window.getComputedStyle(item)
		let $rgb
		if(styles.backgroundColor && styles.backgroundColor != "rgba(0, 0, 0, 0)"){
			$rgb = makeRGB(styles.backgroundColor)
		}else{
			// let parentItem = item.closest(".synopsiscontainer")
			// if (!parentItem){parentItem = item.closest(".scene")}
			let parentItem = item.closest(".scene")
			if (!parentItem && indexCardMode){parentItem = item.closest(".section")?.querySelector(".section-heading")}
			if (!parentItem && !indexCardMode){parentItem = item.closest(".level1")}
			if (!parentItem)return
			styles = window.getComputedStyle(parentItem)
			$rgb = makeRGB(styles.backgroundColor)
		}
			$rgb = $rgb.replace("rgb(", "").replace(")", "").split(",")
		
			let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
			item.style.color = (blackOrWhite > 128) ? "black" : "white"

			// item.innerHTML = styles.backgroundColor + ((blackOrWhite > 128) ? "black" : "white") + item.innerHTML
	}

	mylog("exiting")

}

function blackOrWhite(rgb){

	// if(!rgb.startsWith("rgb"))return null

	let $rgb = rgb.replace("rgb(", "").replace(")", "").split(",")
		
	let blackOrWhite = $rgb[0] * 0.299 + $rgb[1] * 0.587 + $rgb[2] * 0.114;
	let colorOut = (blackOrWhite > 128) ? "black" : "white"


	return colorOut

}

function makeRGB(color){

	if (color == "" || color.substring(0,1) != "#") {return color}

    // This is simples because we know that every values is two 
    // hexadecimal digits.
    	rgbColors[0]=color.substring(1, 3)  // redValue
    	rgbColors[1]=color.substring(3, 5)  // greenValue
    	rgbColors[2]=color.substring(5, 7)  // blueValue

    	rgbColors[0]=parseInt(rgbColors[0], 16)
    	rgbColors[1]=parseInt(rgbColors[1], 16)
    	rgbColors[2]=parseInt(rgbColors[2], 16)
	

	color = "rgb(" + [...rgbColors] + ")"

  return color

}

function recalculatePages(){

	mylog()
	
	let startsOnPage = 1
	let elementNumber = 0
	let firstObjectWithDivider = true

		pageDividers = []

	for (line in outline){
		let currentLine = outline[line]

			//redesigned condition that only omitted scenes do not get added to page count (and synopse for good mesaure)
			//if((currentLine.typeAsString != "Heading" && currentLine.typeAsString != "Synopse") || currentLine.omitted == true){
			if((currentLine.typeAsString == "Synopse") || currentLine.omitted == true || currentLine.titlePage){
				outline[elementNumber].startsOnPage = startsOnPage
				outline[elementNumber].numberOfPages = 0 
				elementNumber ++
			 	continue
			}
	
		outline[elementNumber].startsOnPage = startsOnPage 
		outline[elementNumber].numberOfPages = pages[elementNumber]

				//temporarily adding this here instead of after
					//subsequently moved this into .beatPlugin code instead
				//let extraLineForHeadings = (currentLine.typeAsString == "Heading" && !pageBreaks[elementNumber]) ? 2/58 : 0
				//	startsOnPage += extraLineForHeadings

				if(pageBreaks && pageBreaks[elementNumber]) {

					let whereThisSceneEnds = Math.ceil(startsOnPage + pageBreaks[elementNumber])
					let thisScenesLength = whereThisSceneEnds - startsOnPage
					
					outline[elementNumber].numberOfPages = thisScenesLength // in order to hit a full page
					
				}

				//let's try to add page dividers
				if (pages[elementNumber] > 0 &&
					(Math.trunc(startsOnPage + outline[elementNumber].numberOfPages) >= Math.trunc(startsOnPage) ||
					outline[elementNumber].startsOnPage > Math.ceil(outline[elementNumber - 1]?.startsOnPage + outline[elementNumber - 1]?.numberOfPages)  ||
					firstObjectWithDivider)
					){
							
					//this adds the PG1 line to the first object with a length:
					let numberOfDividers = Math.trunc(startsOnPage + outline[elementNumber].numberOfPages) - Math.trunc(startsOnPage)
						if (firstObjectWithDivider){ numberOfDividers ++ }
						pageDividers[elementNumber] = []

					for (let i = 0; i < numberOfDividers; i++){

						let lengthToDivider = Math.ceil(startsOnPage) - startsOnPage + i
						pageDividers[elementNumber].push(lengthToDivider)

					}
					firstObjectWithDivider = false
				}

				//This is now put BEFORE the divider-adder, so moved away from here
				//let extraLineForHeadings = (currentLine.typeAsString == "Heading" && !pageBreaks[elementNumber]) ? 2/58 : 0
		
		//In prep for next round -- this is where next scene will start.
		startsOnPage += outline[elementNumber].numberOfPages // + extraLineForHeadings

		elementNumber ++
	}
}

function putOntoScreen() {

	let theIndicatorIsInElement = $id("youAreHere")?.getAttribute('data-outlineElementCount')

	if (theIndicatorIsInElement && theIndicatorIsInElement > 0){
		if(isThisOffScreen($id(theIndicatorIsInElement))){
			scrollNicelyIntoView($id(theIndicatorIsInElement))
		}	
	}
}

function recalculateHeights(wherefrom){
	
	mylog()
	mylog("from: " + JSON.stringify(recalculateHeights.caller.name))
	mylog("OLD VALUE: " + getComputedStyle(document.documentElement).getPropertyValue('--heightFactor'))

	let theIndicator = $id("youAreHere")

	let allScenes = $$(".scene, .orphanText")
	let allSections = $$(".section")
	let allActs = $$(".level1")
	
	if ((allScenes.length == 0 && allSections.length == 0) || !outline || outline.length == 0){
		mylog("returns from recalculateHeights because no scenes and no sections")
		return} 

	if (indexCardMode) {
		mylog("indexCardMode was discovered so fine.")
		let referenceForWidth = allSections[0]
		let referenceForHeight = 0
		theRoot.style.setProperty('--indexReferenceForHeight', "auto")
		
		//set height of cards first
		let indexHeight = "calc(22px * var(--fontSizeFactor) + " + indexCardHeight + " * 15px * var(--fontSizeFactor))" 
		theRoot.style.setProperty('--indexCardHeight', indexHeight)

		if ($(".altYouAreHere")) {$(".altYouAreHere").classList.remove("altYouAreHere")}
		putOntoScreen()
		if(theIndicator){theIndicator.style.top = "calc(16px * var(--fontSizeFactor))"}

		//then set height of act lanes
		if (oneColumnOutline == 0){
			for (act of allActs){
				referenceForHeight = Math.max(referenceForHeight, Number(act.getBoundingClientRect().bottom) - Number(act.getBoundingClientRect().top))
				}
			theRoot.style.setProperty('--indexReferenceForHeight', referenceForHeight + "px")
		}
		
		return
	}

	if(areScenesProportional != 1){ //would be better if this were a class instead! 
				
		if(theIndicator){
			let a = getComputedStyle(theRoot).getPropertyValue('--fixedHeight')
			let theIndicatorPosition = "calc(var(--fixedHeight) * var(--fontSizeFactor) * 2 / 3)"
				if (a = "auto"){theIndicatorPosition = "calc(11px * var(--fontSizeFactor))"}
			theIndicator.style.top = theIndicatorPosition
		}
		
		putOntoScreen()
		return	
	}
	
	// The rest is for proportional only 
	//==================================

	console.time("recalculateHeights")

	//new section-height-collector
		let newSectionHeights = []
		let newSceneHeights = []
		for (act of allActs){

			if (act.classList.contains(".boneyard")) break

			let sectionsInAct = act.querySelectorAll(".section-heading") //this includes the act itself
			let scenesInAct = act.querySelectorAll(".scene, .orphanText")
			let sectionHeightForAct = 0
			for (sec of sectionsInAct) {

				let measures = window.getComputedStyle(sec)
				sectionHeightForAct += sec.getBoundingClientRect().height + parseInt(measures.marginBottom) + parseInt(measures.marginTop)
			}
			let sceneHeightForAct = 0
			for (scn of scenesInAct){

				sceneHeightForAct += Number(scn.dataset.lengthOfScene)
				
				// the following will produce undexpected results after a while -- bug in webkit?
				// scn.style.height = "calc(" + scn.dataset.lengthOfScene + "px * var(--heightFactor)" //scn.dataset.lengthOfScene
				
				scn.style.minHeight = ""
				scn.style.setProperty("--flexibleHeight", scn.dataset.lengthOfScene + "px")

			}
			newSectionHeights.push(sectionHeightForAct)
			newSceneHeights.push(sceneHeightForAct)
		}

	let theLongestAct = Math.max(...newSceneHeights)
	let theMostSections = Math.max(...newSectionHeights)
	
	let whichActHasLongestScenes = newSceneHeights.indexOf(theLongestAct)
	let whichActHasMostSections = newSectionHeights.indexOf(theMostSections)
	
	let windowHeight = $id('flexiContainer').getBoundingClientRect().height

	let spaceToBreatheAndForPageNumbers = 80
	let newSpaceToDistribute = windowHeight - spaceToBreatheAndForPageNumbers

		unDistributableHeight = windowHeight - newSpaceToDistribute //only used for exporting
	
	let scenesHaveMoreSpace = (newSpaceToDistribute - newSectionHeights[whichActHasLongestScenes] - theLongestAct) / theLongestAct
	let sectionsHaveMoreSpace = (newSpaceToDistribute - (theMostSections) - newSceneHeights[whichActHasMostSections]) / newSceneHeights[whichActHasMostSections]
	
	let heightFactor =  Math.min(scenesHaveMoreSpace, sectionsHaveMoreSpace)
		paperHeightFactor = 72 * (29.7 / 2.54) * heightFactor / (windowHeight - 200) //was-160, and before that -120 
		theRoot.style.setProperty('--heightFactor', heightFactor);
		mylog("HeightFactor, NEW VALUE: " + heightFactor + "")
		
		setTimeout(hideSlugFor, 150)

		if(theIndicator){positionTheIndicator(theIndicator)}

		mylog("exiting recalculateHeights()")
		putOntoScreen()

	//let outTime = new Date()
	console.timeEnd("recalculateHeights")
}

function positionTheIndicator(){
	
	mylog()

	let theIndicator = $id("youAreHere")
	if(!theIndicator)return

		let theIndicatorPercentage
	
		let theIndicatorIsInElement = theIndicator.getAttribute('data-outlineElementCount');
		theIndicatorPercentage = Number(theIndicator.getAttribute('data-percentageIntoScene'));

			// let theIndicatorParentHeight = Number(parseInt(window.getComputedStyle(theIndicator.parentNode).getPropertyValue("height")));
			let theIndicatorParentHeight = parseInt(theIndicator.parentNode.getBoundingClientRect().height);
			let theIndicatorPosition = theIndicatorParentHeight * theIndicatorPercentage
			if (theIndicatorPercentage == -1) {theIndicatorPosition = 11 * currentZoomLevel}
			theIndicator.style.top = theIndicatorPosition + "px"

			if (theIndicatorIsInElement){
			if(isThisOffScreen($id(theIndicatorIsInElement))){
				scrollNicelyIntoView($id(theIndicatorIsInElement))
			}	
		}

	if(currentParentScroll){
		
		let a = $id(theIndicatorIsInElement).querySelector(".synopsiscontainer")
			a.scrollTo({left: 0, top: currentParentScroll, behavior: "instant"})
	}
}

function hideSlugFor(entries){
	
	if (indexCardMode || $id("flexiContainer").classList.contains("nonProportionalMode")) {return}

	//don't think i will go back to resizeobserver, so "entries" will probably never be passed here.
	
		// if(entries){
		// 	for (let entry of entries){
		// 		if (Number(entry.contentRect.height) < (10.5 * currentZoomLevel)){
		// 			entry.target.classList.add("hideSlugIfSmall")
		// 		}else{
		// 			entry.target.classList.remove("hideSlugIfSmall")
		// 		}
		// 	}
		// }else{

		let scenes = $$(".scene")
			
			for (let scene of scenes){
			
			if (Number(scene.getBoundingClientRect().height) < (11.5 * currentZoomLevel)){
				scene.classList.add("animateOpacity")
				scene.classList.add("hideSlugIfSmall")
			}else{
				scene.classList.remove("hideSlugIfSmall")
			}
		}
	// }
}

function youAreHere(location, length, positionChangeOnly){
	mylog("youAreHere: " + location + "...")
	mylog("...and we are editing text is: " + weAreCurrentlyEditingText)

	if(location == 0 ){location = -999} //hacky way to avoid errors when no location at all, yet process when zero

	if(fullTypeTimer || !location || !outline || outline.length < 1 || weAreCurrentlyEditingText){
		if(document.getElementById('youAreHere')){document.getElementById('youAreHere').remove()}
		mylog("CANCELING YOU ARE HERE")
		return
	}

	let whichSceneAreWeIn = 0
		while ((outline[whichSceneAreWeIn + 1]) && outline[whichSceneAreWeIn + 1].line.position - 0 <= location){ 		
			whichSceneAreWeIn ++
		}

		//This was added to keep the scroll of enclosing index card when selecting a synopsis (2022-07-02)
		currentParentScroll = $id(whichSceneAreWeIn)?.closest(".scene, .section")?.querySelector(".synopsiscontainer")?.scrollTop

		if(document.getElementById('youAreHere')){
			document.getElementById('youAreHere').remove()
		}

		if (outline[whichSceneAreWeIn].typeAsString != "Synopse"){
			currentParentScroll = false
		}
		while(outline[whichSceneAreWeIn].typeAsString == "Synopse"){
			whichSceneAreWeIn--
			if(whichSceneAreWeIn < 0){whichSceneAreWeIn = 0; break}
		}
		if(outline[whichSceneAreWeIn].omitted == 1 && areScenesProportional == 1) {
			return
		}	

		mylog("we are in... " + whichSceneAreWeIn)
		
	let whichSceneNumberAreWeIn = outline[whichSceneAreWeIn].sceneNumber
		
	let thisScenesBeginning = outline[whichSceneAreWeIn].sceneStart
		if(outline[whichSceneAreWeIn].sceneNumber.includes("OMITTED")){
			thisScenesBeginning = outline[whichSceneAreWeIn].line.position
		} //if we need to fix the sceneNumber for later use?
		
	let thisScenesEnd = outline[whichSceneAreWeIn].sceneEnd
		if(outline[whichSceneAreWeIn].sceneNumber.includes("OMITTED") && outline[whichSceneAreWeIn + 1]){
			thisScenesEnd = outline[whichSceneAreWeIn+1].line.position - 1
		} //if we need to fix the sceneNumber for later use?
		if(outline[whichSceneAreWeIn].typeAsString == "Section"){
			if (outline[whichSceneAreWeIn + 1]){thisScenesEnd = outline[whichSceneAreWeIn + 1].line.position - 1} //so not end of entire sequence
		}
		
	//First, setting place to put indicator, so we can change it if we need to go into orphan text
	let placeToPutIndicator = $id(whichSceneAreWeIn)
	mylog("we shall now put indicator in " + whichSceneAreWeIn)
		
	var percentageIntoScene = (location - thisScenesBeginning) / (thisScenesEnd - thisScenesBeginning); // must also fix end position in plugin before delivering JSON
	
		if (pageBreaks[whichSceneAreWeIn]){

			percentageIntoScene = percentageIntoScene * pageBreaks[whichSceneAreWeIn]/outline[whichSceneAreWeIn].numberOfPages
		}

		if(!outline[whichSceneAreWeIn].sceneNumber || outline[whichSceneAreWeIn].typeAsString == "Section"){
			
			percentageIntoScene = -1
			
			//BUT: the following is to allow traveling you-are-here in "orphan text" after section 
			if (outline[whichSceneAreWeIn].typeAsString == "Section"
			&& outline[whichSceneAreWeIn].numberOfPages > 0 
			&& location > thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length
			&& areScenesProportional == 1){

				if(outline[whichSceneAreWeIn + 1]){//for all orphan texts that does not end the document

					let nextElement = 1
					while (outline[whichSceneAreWeIn + nextElement] && outline[whichSceneAreWeIn + nextElement].typeAsString == "Synopse"){nextElement++}
										
					try{
						percentageIntoScene = (location - (thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)) / (outline[whichSceneAreWeIn + nextElement].sceneStart - 1 - thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)
					}catch{
						mylog("inside catch")
						percentageIntoScene = (location - (thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)) / (absoluteTextLength - thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)
					}
					
					mylog("before put in orphan")
					placeToPutIndicator = placeToPutIndicator.querySelector(".orphanText")
				}else{ //the special case where there is no more outline elements after the section, just orphan text

					percentageIntoScene = (location - (thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)) / (outline[whichSceneAreWeIn].sceneEnd - thisScenesBeginning + outline[whichSceneAreWeIn].line.string.length)
					placeToPutIndicator = placeToPutIndicator.querySelector(".orphanText")
				}
			}
		}

		let weReOnPage = placeToPutIndicator.querySelectorAll(".pageDivider")
		//while (!weReOnPage && whichSceneAreWeIn > -1) weReOnPage = 
		
		let theIndicatorHTML = "<div " + 
		"id='youAreHere' " +
		"class='indicator' " +
		"data-percentageIntoScene='" + percentageIntoScene + "' " +
		"data-outlineElementCount='" + whichSceneAreWeIn + "' " +
		"data-theSceneNumber = '" + whichSceneNumberAreWeIn + "' " + 
		">"+"<p>"+ location + //" (" + outline[whichSceneAreWeIn].typeAsString + ")" + 
		"</p></div>"
		
		if(placeToPutIndicator){
			placeToPutIndicator.innerHTML += theIndicatorHTML
		}

	mylog("End of indicator placement")
	if(positionChangeOnly){
		if($id("youAreHere")) {positionTheIndicator($id("youAreHere"))}
	}else{
		recalculateHeights("from youAreHere")
	}
}

function numberIntoEights(theNumber) {

	let theFraction = Math.floor((theNumber - Math.floor(theNumber))*8);
	
	let theNumberInEights = theFraction + "/8";
	if(theNumberInEights == "0/8" && Math.floor(theNumber) > 0){theNumberInEights = "pgs"; if (Math.floor(theNumber)==1){theNumberInEights = "pg"}}
	
	if (Math.floor(theNumber) > 0){theNumberInEights = 	Math.floor(theNumber)+" " + theNumberInEights};
	
	return theNumberInEights;

}

// MARK: - UI RELATED

function __________UI_RELATED_STUFF (){}


function saveCurrentState() {
	mylog()

	mylog("scenes: " + cardStateForScenes)
	mylog("sections: " + cardStateForSections)
	rememberCardState()
	mylog("scenes: " + cardStateForScenes)
	mylog("sections: " + cardStateForSections)

	documentSetting = {
		showProportional: areScenesProportional,
		showNumbers: whatAreSceneNumbers,
		showLengths: whatAreSceneLengths,
		showPages: whatArePageNumbers,
		oneColumnOutline: oneColumnOutline,
		currentZoomLevel: currentZoomLevel,
		notepanelWidth: parseInt(getComputedStyle(theRoot).getPropertyValue('--note-panel-width')),

		noteButtonGreen: $id("noteButtonGreen")? $id("noteButtonGreen").checked : true,
		noteButtonYellow: $id("noteButtonYellow")? $id("noteButtonYellow").checked : true,
		noteButtonRed: $id("noteButtonRed")? $id("noteButtonRed").checked : true,
		noteButtonMagenta: $id("noteButtonMagenta")? $id("noteButtonMagenta").checked : true,
		noteButtonPurple: $id("noteButtonPurple")? $id("noteButtonPurple").checked : true,
		noteButtonReview: $id("noteButtonReview")? $id("noteButtonReview").checked : false,

		indexCardMode: indexCardMode,
		indexCardHeight: indexCardHeight,

		cardStateForScenes: [...cardStateForScenes],
		cardStateForSections: [...cardStateForSections],

		notesAreDisplayed: notesAreDisplayed,
		markersAreDisplayed: markersAreDisplayed,
		beatsAreDisplayed: beatsAreDisplayed,
		reviewsAreDisplayed: reviewsAreDisplayed,

		greyonly: ($id("flexiContainer").classList.contains("greyonly")),
		notepanel: ($id("notepanel").classList.contains("expanded")),
		showSynopsisInScenes: ($id("flexiContainer").classList.contains("showSynopsisInScenes")),
		showMultipleSceneLines: ($id("flexiContainer").classList.contains("dualSceneLines")),
		showMultipleSectionLines: ($id("flexiContainer").classList.contains("dualSectionLines")),
		allowLowerCaseSections: ($id("flexiContainer").classList.contains("allowLowerCaseSections")),
		showVerticals: ($id("flexiContainer").classList.contains("verticals")),
		showPageDividers: ($id("flexiContainer").classList.contains("showPageDividers")),
		showPageDividersAlways: ($id("flexiContainer").classList.contains("always")),

		documentName: (documentName || false),
		documentSubName: (documentSubName || false),
		documentAuthor: (documentAuthor || false),

		boneyardIsClosed: ($id("flexiContainer").classList.contains("boneyardIsClosed")),

		trackingIncludesSynopsis: documentSetting.trackingIncludesSynopsis,

		showRevisions: documentSetting.showRevisions
	}

	mylog("documentSettings done")

	userDefault = {
		realTimeUpdates: isRealTimeOn,
		warningsAreOn: warningsAreOn,
		colorScheme: colorScheme,

		loggingIsOn: loggingIsOn,
		invertTextOnDark: invertTextOnDark,

		excludeVoiceOvers: userDefault.excludeVoiceOvers
	}

	mylog ("now looping all defaults into object")

	
		for([key, value] of Object.entries(documentSetting)){
			Beat.call(`Beat.setDocumentSetting('${key}', '${value}')`)
			mylog(`NOW STORING: ('${key}', '${value}')`)
		}
		
		for([key, value] of Object.entries(userDefault)){
			Beat.call(`Beat.setUserDefault('${key}', '${value}')`)
			mylog(`NOW STORING: ('${key}', '${value}')`)
		}
	
	if(!isFullScreen)Beat.call("Beat.custom.saveWindowSize()")		

}

function getDefaults(){
	Beat.log("BELOW SHOULD BE A LIST OF STUFF")

	for([key,value] of Object.entries(userDefault)){
		Beat.log(key +": " + value)
	}

	for([key,value] of Object.entries(documentSetting)){
		Beat.log(key +": " + value)
	}

	mylog("Objects retreived")

	//USER DEFAULTS

		loggingIsOn = userDefault.loggingIsOn || false
		isRealTimeOn = userDefault.isRealTimeOn || 1
		colorScheme = userDefault.colorScheme || "Beat"
		Beat.log("colorScheme is " + colorScheme + " because userdef is " + userDefault.colorScheme)
		warningsAreOn = userDefault.warningsAreOn
			warningsAreOn = (warningsAreOn == true)

		invertTextOnDark = userDefault.invertTextOnDark || true

	mylog("User defaults done")

	//DOCUMENT SETTINGS

		areScenesProportional = documentSetting.areScenesProportional
			if(areScenesProportional != "0"){areScenesProportional = 1}

		whatAreSceneLengths = documentSetting.whatAreSceneLengths || "inline"
		whatAreSceneNumbers = documentSetting.whatAreSceneNumbers || "inline"
		whatArePageNumbers = documentSetting.whatArePageNumbers || "inline"
		oneColumnOutline = documentSetting.oneColumnOutline || 0
		currentZoomLevel = documentSetting.currentZoomLevel || 1
		if (documentSetting.notepanelWidth) theRoot.style.setProperty('--note-panel-width', documentSetting.notepanelWidth + "px") 

		// if ($(".noteButtons")){
		// 	if($id("noteButtonGreen")) $id("noteButtonGreen")?.checked = (documentSetting.noteButtonGreen) || true
		// 	if($id("noteButtonYellow")) $id("noteButtonYellow")?.checked = (documentSetting.noteButtonYellow) || true
		// 	if($id("noteButtonRed")) $id("noteButtonRed")?.checked = (documentSetting.noteButtonRed) || true
		// 	if($id("noteButtonMagenta")) $id("noteButtonMagenta")?.checked = (documentSetting.noteButtonMagenta) || true
		// 	if($id("noteButtonPurple")) $id("noteButtonPurple")?.checked = (documentSetting.noteButtonPurple) || true
		// 	if($id("noteButtonReview")) $id("noteButtonReview")?.checked = (documentSetting.noteButtonReview) || false
		// }

		indexCardHeight = documentSetting.indexCardHeight || 5
		indexCardMode = documentSetting.indexCardMode || false
			if(indexCardMode == "false" || indexCardMode == 0 || indexCardMode == "0"){indexCardMode = false}
			if(indexCardMode != false){indexCardMode = true} 

		theDocumentsWidth = documentSetting.theDocumentsWidth
		theDocumentsHeight = documentSetting.theDocumentsHeight

		notesAreDisplayed = documentSetting.notesAreDisplayed || false
		markersAreDisplayed = documentSetting.markersAreDisplayed || false
		beatsAreDisplayed = documentSetting.beatsAreDisplayed || false
		reviewsAreDisplayed = documentSetting.reviewsAreDisplayed || false

		$id("flexiContainer").classList.toggle("greyonly", documentSetting.greyonly || false)
		if (documentSetting.notepanel){toggleNotepanel()}
		$id("flexiContainer").classList.toggle("showSynopsisInScenes", documentSetting.showSynopsisInScenes || false)
		$id("flexiContainer").classList.toggle("boneyardIsClosed", documentSetting.boneyardIsClosed || true)

		theWindowsPositionX = documentSetting.theWindowsPositionX
		theWindowsPositionY = documentSetting.theWindowsPositionY

		cardStateForScenes = documentSetting.cardStateForScenes || []
		cardStateForSections = documentSetting.cardStateForSections || []

			for(let i = 0; i<cardStateForScenes.length; i++){
			mylog("#" + i + " -- scene: " + cardStateForScenes[i] + ", section:  " + cardStateForSections[i])
			}

		documentName = documentSetting.documentName
		documentSubName = documentSetting.documentSubName
		documentAuthor = documentSetting.documentAuthor

	//NOW EXECUTING SOM STUFF BASED ON THE DEFAULTS WE GOT!

	document.documentElement.setAttribute('data-theme', colorScheme)
	Beat.log("setting color to " + colorScheme)
	$id("flexiContainer").style.display = flexOrInLineBlock[oneColumnOutline]
	
	$id("flexiContainer").classList.toggle("dualSceneLines", documentSetting.showMultipleSceneLines)
	$id("flexiContainer").classList.toggle("dualSectionLines", documentSetting.showMultipleSectionLines)
	$id("flexiContainer").classList.toggle("verticals", documentSetting.showVerticals)
	$id("flexiContainer").classList.toggle("allowLowerCaseSections", documentSetting.allowLowerCaseSections)
	$id("flexiContainer").classList.toggle("showPageDividers", documentSetting.showPageDividers)
	$id("flexiContainer").classList.toggle("always", documentSetting.showPageDividersAlways)

	if(areScenesProportional != 1){
		document.getElementById("flexiContainer").classList.add("nonProportionalMode")
	}

	//REMOVED THIS because the outline isn't built yet, breaking the cardstate arrays
		// if(indexCardMode || areScenesProportional != 1){
		// 	recallCardState()
		// }

	if (indexCardMode){
		toggleIndexCardMode(true)
		toggleIndexCardMode(true)
		// parameter only used when restoring values to allow setting mode in spite of no elements yet.
	}

	theRoot.style.setProperty('--proportionalScenes', areScenesProportional);
	theRoot.style.setProperty('--showSceneLength', whatAreSceneLengths);
	theRoot.style.setProperty('--showSceneNum', whatAreSceneNumbers);
	theRoot.style.setProperty('--showPageNum', whatArePageNumbers);
	theRoot.style.setProperty('--fontSizeFactor', currentZoomLevel)

	setAllButtons()
	mylog("DONE getting defaults")

}

function OLD_getDefaults(){
	mylog("getDefaults()")

loggingIsOn = document.getElementById('theDataDiv').getAttribute('data-logging')

areScenesProportional = document.getElementById('theDataDiv').getAttribute('data-showProportional')
mylog("areScenes...:" + areScenesProportional)

	if(areScenesProportional != "0"){areScenesProportional = 1}

mylog("areScenes...:" + areScenesProportional)

whatAreSceneLengths = document.getElementById('theDataDiv').getAttribute('data-showLengths')
whatAreSceneNumbers = document.getElementById('theDataDiv').getAttribute('data-showNumbers')
whatArePageNumbers = document.getElementById('theDataDiv').getAttribute('data-showPages')
isRealTimeOn = document.getElementById('theDataDiv').getAttribute('data-realTimeUpdates')
colorScheme = document.getElementById('theDataDiv').getAttribute('data-colorScheme')
oneColumnOutline = document.getElementById('theDataDiv').getAttribute('data-oneColumnOutline')
warningsAreOn = document.getElementById('theDataDiv').getAttribute('data-warningsAreOn')
	warningsAreOn = (warningsAreOn == "true")
currentZoomLevel = document.getElementById('theDataDiv').getAttribute('data-currentZoomLevel')

indexCardHeight = document.getElementById('theDataDiv').getAttribute('data-indexCardHeight')
indexCardMode = ($id('theDataDiv').getAttribute('data-indexCardMode')) || false
	
	if(indexCardMode == "false" || indexCardMode == 0 || indexCardMode == "0"){indexCardMode = false}
	if(indexCardMode != false){indexCardMode = true} 

if(cardStateForScenes.length > 0){
		cardStateForScenes = $id('theDataDiv').getAttribute('data-cardStateForScenes')?.split(",") || []
		for(let i = 0; i < cardStateForScenes.length; i++) {cardStateForScenes[i] = JSON.parse(cardStateForScenes[i])}
	}
if(cardStateForSections.length > 0){
		cardStateForSections = $id('theDataDiv').getAttribute('data-cardStateForSections')?.split(",")  || []
		for(let i = 0; i < cardStateForScenes.length; i++) {cardStateForSections[i] = JSON.parse(cardStateForSections[i])}
	}

document.documentElement.setAttribute('data-theme', colorScheme)
document.getElementById("flexiContainer").style.display = flexOrInLineBlock[oneColumnOutline]

theDocumentsWidth = document.getElementById('theDataDiv').getAttribute('data-thePanelWidth')
theDocumentsHeight = document.getElementById('theDataDiv').getAttribute('data-thePanelHeight')

theWindowsPositionX = document.getElementById('theDataDiv').getAttribute('data-xposition')
theWindowsPositionY = document.getElementById('theDataDiv').getAttribute('data-yposition')

if(areScenesProportional != 1){
	document.getElementById("flexiContainer").classList.add("nonProportionalMode")
}

	if(indexCardMode || areScenesProportional != 1){
		recallCardState()
	}

	if (indexCardMode){

		toggleIndexCardMode(true)
		toggleIndexCardMode(true)
		// parameter only used when restoring values to allow setting mode in spite of no elements yet.
	}

theRoot.style.setProperty('--proportionalScenes', areScenesProportional);
theRoot.style.setProperty('--showSceneLength', whatAreSceneLengths);
theRoot.style.setProperty('--showSceneNum', whatAreSceneNumbers);
theRoot.style.setProperty('--showPageNum', whatArePageNumbers);
theRoot.style.setProperty('--fontSizeFactor', currentZoomLevel)

}

function forceRestart(){

		saveCurrentState()
		Beat.call("Beat.custom.reloadCode()")
		return
	
}

function __________LISTENING (){}

function checkWhatKeyGotPressed(someoneJustPressed) {
	mylog("checkWhatKeyGotPressed(" + someoneJustPressed.key + ")")
	
	//if (someoneJustPressed.key == " " && !someoneJustPressed.altKey) {event.preventDefault(); setSharedScreen()}
	//if (someoneJustPressed.key == "j") {event.preventDefault(); toggleFullScreen()}
	
	//if (someoneJustPressed.key == "" && !someoneJustPressed.altKey) {event.preventDefault(); forceRestart()}
	if (someoneJustPressed.key == "" && !someoneJustPressed.altKey) {event.preventDefault(); Beat.call(`Beat.custom.reloadHTML()`)}
	


	if (someoneJustPressed.key == "Escape") {
		
		event.preventDefault()
		if(errorHasFired){return}

		if ($id("advancedSettings")) $id("advancedSettings").close()
		if ($id("menu")){closeNewMenu(); return false}
		if (helpContainerVisibility == 1) {toggleHelpContainer(); return false}
		if (settingsContainerVisibility == 1) {toggleSettingsContainer(); return false}
		if (trackingContainerVisibility == 1) {toggleTrackingContainer(); return false}
		if ($id('aboutBox')){toggleTrackingContainer(true); return false}
		if ($id('textContainer')){toggleTrackingContainer(true); return false}
		if (contextMenuIsOpen) {closeContextMenu(); return false}
		if ($(".wider")) {$(".wider").classList.remove("wider"); return false}
		if ($('.expandedReview')) {collapseReviews(); return false}
		if ($id('expandedNote')) {collapseNote(); return false}
		if (aBeatIsHovered) {unhoverAllBeats(); return false}
		if (beatsAreDisplayed) {toggleDisplayBeats(); return false}
		if ($id("notepanel").classList.contains("expanded")){toggleNotepanel(); return false}
		if ($id("flexiContainer").classList.contains("uncolorAllScenesBut")){muteColors(); return false}
		if (characterMenuList?.selectedIndex != -1) {deselectAllCharacters(); return false}
		if (notesAreDisplayed) {toggleDisplayNotes(); return false}

		//Beat.call("Beat.custom.reallyQuit()")
		return
	}

	if (errorHasFired && someoneJustPressed.key == "Enter") {
		event.preventDefault()
		document.getElementById("errorClickButton").click()
    }else if (someoneJustPressed.key == "Enter") {

		if($(".modal")){event.preventDefault(); $(".modal").close(); return}
		
		event.preventDefault()
		let elements = $$(".section-heading.isSelected, .scene.isSelected, .synopsis.isSelected")
		let element = elements[elements.length - 1]
		if (element){
			let rect = element.getBoundingClientRect()
			contextMenu(element, (rect.x + rect.width/2), rect.y, true)
		}
	}
	
	if(errorHasFired){return} // nothing else is allowed when the error box is up.

	// if (someoneJustPressed.key == "'" && !event.metaKey) {event.preventDefault(); showNewMenu($id("helpButton"), "showStuffMenu")}
	
	// 1. LETTERS

	if (someoneJustPressed.key == "a" && event.ctrlKey) {event.preventDefault(); selectAllElements(true)}
	if (someoneJustPressed.key == "a" && event.metaKey) {event.preventDefault(); selectAllElements(false)}
	if (someoneJustPressed.key == "b" && event.metaKey) {event.preventDefault(); addShowHideBoneyard(); return}
	if (someoneJustPressed.key == "b") {event.preventDefault(); toggleDisplayBeats()}

	if (someoneJustPressed.key == "c" && event.ctrlKey) {
		event.preventDefault()
		document.getElementById("flexiContainer").classList.toggle("greyonly")
		if(invertTextOnDark){
			// weAreChangingColors = true
			// startSmallUpdate()
			reevaluateColorContrast()
		}
		setAllButtons()
		return
	}
	if (someoneJustPressed.key == "c") {event.preventDefault(); toggleColorScheme()}
		
	if (someoneJustPressed.key == "d" && event.metaKey) {event.preventDefault(); deselectAllElements(false)}
	if (someoneJustPressed.key == "d") {event.preventDefault(); expandOrCollapseSections(); return}
	if (someoneJustPressed.key == "e" && event.metaKey) {event.preventDefault(); togglePrintMode(true); return}
	if (someoneJustPressed.key == "e") {event.preventDefault(); anArrowWasClicked($(".arrowForIndexCards"), true); return}
	if (someoneJustPressed.key == "f" && !event.metaKey) {event.preventDefault(); toggleProportional()}
	
	if (someoneJustPressed.key == "h" && !event.ctrlKey) {event.preventDefault(); outdoorMode()}
	if (someoneJustPressed.key == "h" && event.ctrlKey) {event.preventDefault(); flexiContainer.classList.toggle("horizontal")}
	
	// if (someoneJustPressed.key == "j") {event.preventDefault(); Beat.call("Beat.custom.alertJSON()"); return}

	if (someoneJustPressed.key == "l") {event.preventDefault(); toggleShowSceneLength()}
	if (someoneJustPressed.key == "m" && !event.ctrlKey) {event.preventDefault(); toggleDisplayMarkers()}
	if (someoneJustPressed.key == "m" && event.ctrlKey) {event.preventDefault(); flexiContainer.classList.toggle("unShowMarkerText")}
	if (someoneJustPressed.key == "n") {event.preventDefault(); toggleDisplayNotes()}
	if (someoneJustPressed.key == "o") {event.preventDefault(); toggleOneColumnOutline()}

	if (someoneJustPressed.key == "p" && event.ctrlKey && event.altKey) {event.preventDefault(); $id("buttonForAlways").click(); return}
	if (someoneJustPressed.key == "p" && event.ctrlKey) {event.preventDefault(); $id("buttonForPageDividers").click(); return}
	if (someoneJustPressed.key == "p" && event.shiftKey && event.metaKey) {event.preventDefault(); event.stopPropagation(); newPrintBox(); return}
	if (someoneJustPressed.key == "p" && event.metaKey) {event.preventDefault(); togglePrintMode(); return}
	if (someoneJustPressed.key == "p") {event.preventDefault(); toggleShowPageNumbers()}

	if (someoneJustPressed.key.toLowerCase() == "q" && !someoneJustPressed.metaKey) {event.preventDefault(); makeWider(false, true, event.shiftKey)}
	
	// if (someoneJustPressed.key == "r") {event.preventDefault(); toggleRealTime()}
	if (someoneJustPressed.key == "r") {event.preventDefault(); toggleDisplayReviews()}
	if (someoneJustPressed.key == "s" && someoneJustPressed.ctrlKey && !event.metaKey) {event.preventDefault(); $id('buttonForDualLines')?.click(); return}
	if (someoneJustPressed.key == "s" && !someoneJustPressed.ctrlKey && !event.metaKey) {event.preventDefault(); toggleShowSceneNumbers()}
	if (someoneJustPressed.key == "t" && someoneJustPressed.ctrlKey) {event.preventDefault(); $id('buttonForDualSectionLines')?.click(); return}
	if (someoneJustPressed.key == "t" && !someoneJustPressed.ctrlKey) {event.preventDefault(); toggleTrackingContainer()}
	if (someoneJustPressed.key == "u" && someoneJustPressed.ctrlKey && !event.metaKey) {event.preventDefault(); $id('buttonForLowerCase')?.click(); return}
	if (someoneJustPressed.key == "v" && someoneJustPressed.ctrlKey && !event.metaKey) {event.preventDefault(); $id('buttonForVerticals')?.click(); return}


	if (someoneJustPressed.key == "w" && event.metaKey) {event.preventDefault(); Beat.call("Beat.custom.reallyQuit(true)")}
	if (someoneJustPressed.key == "w") {event.preventDefault(); toggleWarnings()}

	if (someoneJustPressed.key == "x") {event.preventDefault(); toggleIndexCardMode()}
	if (someoneJustPressed.key == "y" && !event.ctrlKey) {event.preventDefault(); toggleDisplaySynopsis()}
	if (someoneJustPressed.key == "y" && event.ctrlKey) {event.preventDefault(); flexiContainer.classList.toggle("onlySynopsis"); setAllButtons()}
	if (someoneJustPressed.key == "z" && event.metaKey) {saveCurrentState(); weAreChangingColors == true} //hack to improve redraw speed when undoing


	// 2. NON-LETTERS

	if (someoneJustPressed.key == "," && someoneJustPressed.metaKey) {event.preventDefault(); if(!$id("advancedSettings").open)$id("advancedSettings").showModal(); setAllButtons()}

	if (someoneJustPressed.key == "*") {event.preventDefault(); toggleShowRevisions()}
	
	if (someoneJustPressed.key == "F1") {event.preventDefault(); cycleMenus(event.shiftKey)}
	if (someoneJustPressed.key == "?") {event.preventDefault(); toggleHelpContainer()}
	if (someoneJustPressed.key == "") {event.preventDefault(); 
		toggleNotepanel();
		return}

	if (someoneJustPressed.key == "Backspace" && event.metaKey) {event.preventDefault(); deleteScene()}

	if (someoneJustPressed.key == "Tab" && event.ctrlKey && event.shiftKey) {Beat.call("Beat.previousTab()"); return}
	if (someoneJustPressed.key == "Tab" && event.ctrlKey) {Beat.call("Beat.nextTab()"); return}
	if (someoneJustPressed.key == "Tab" && !event.ctrlKey) {event.preventDefault(); cycleNotes(event.shiftKey)}


	// 3. DIGITS
	
	if (event.metaKey && event.ctrlKey && (someoneJustPressed.key == "=" || someoneJustPressed.key == "+" || someoneJustPressed.key == "-" || someoneJustPressed.code == "Digit0")){
		event.preventDefault(); changeIndexCardHeight(someoneJustPressed.key); return
	}
	if (event.metaKey && (someoneJustPressed.key == "=" || someoneJustPressed.key == "+" || someoneJustPressed.key == "-" || someoneJustPressed.code == "Digit0")){
		event.preventDefault(); zoomSizes(someoneJustPressed.key)
	}

	if (someoneJustPressed.code == "Digit0") {event.preventDefault(); deselectAllCharacters(); return false}
	if(someoneJustPressed.code.startsWith("Digit")) {
		event.preventDefault(); toggleSoloCharacter(someoneJustPressed.code.substr(-1,1))}

	// 4. ARROWS

	if ((someoneJustPressed.code == "ArrowUp" || someoneJustPressed.code == "ArrowDown")
		&&
		(!someoneJustPressed.metaKey && !someoneJustPressed.ctrlKey)){
			event.preventDefault(); walkTheOutline(event)
	}

	// 5. MODIFIERS
		
	if (someoneJustPressed.key == "Alt") {
		altIsBeingPressed = true
		$("#flexiContainer").classList.add("showAddButton")

		if(currentlyHoveredElement){
			insertAddButton(currentlyHoveredElement)
			addPromoteButtons(currentlyHoveredElement)
		}
		mylog("currently hovering: " + currentlyHoveredElement)		
		
	} 
}
	
function checkWhatKeyWasReleased(someoneJustReleased){
	mylog()
	if (someoneJustReleased.key == "Alt") {
		altIsBeingPressed = false
		previouslyHovered = false
		document.getElementById("printButton").innerHTML = printerIcon
		$("#flexiContainer").classList.remove("showAddButton")
		if($id("addButton")){removeAddButton()}
		removePromoteButtons()
	}	
}

function somethingWasClicked() {
	mylog()

	mylog("somethingWasClicked: " + event.target.classList + event.target.id + event.target)
	mylog("flexiContainer now has...:" + $id("flexiContainer").classList)

	if(event.target.closest(".bottomButton")){mylog("return out of clicked"); return}
	if($id("synEditBox")) return

	let theClickedThing = event.target
	let theButton = event.button
	let rightClick = event.ctrlKey || theButton == 2
	let length

	// console.log(theClickedThing)
	// console.log(theClickedThing.closest(".scene, .section")?.id, outline[theClickedThing.closest(".scene, .section")?.id])

	let a = [...theClickedThing.classList]

	if (a.includes("arrowForIndexCards") || a.includes("sectionArrow")){
		anArrowWasClicked(theClickedThing); 
		return	
	}

	if (a.includes("generalButtonStyle")){
		mylog("returns because .generalButtonStyle")
		return
	}

	if (a.includes("synopsiscontainer")){
		theClickedThing = theClickedThing.parentNode
		a = [...theClickedThing.classList]
	}

	if (a.includes("boneyard") || (a.includes("section-heading") && theClickedThing.closest(".section").classList.contains("boneyard"))){

		$id("flexiContainer").classList.toggle("boneyardIsClosed")
		return

	}

	if (a.includes("widerButton") || a.includes("widerButtonOn")) {makeWider(theClickedThing)}

	mylog("before if(event.altKey)")

	if(event.altKey){
		switch(theClickedThing.id){
			case "addScene":
				mylog("case: addScene")
				addElement(theClickedThing)
				return
			case "addSection":
				mylog("case: addSection")
				addElement(theClickedThing)
				return
			default:
				muteColors(theClickedThing, event.shiftKey) 
				//NOTE: sending literal clicked thing here, so can be either scene or sceneheading!
				return
		}
	}

	let gotoIndex = Math.max(parseInt(theClickedThing.getAttribute("data-line")), 1)
	
	// if (theClickedThing.id == "expandedNote" || theClickedThing.id == "trashNote"){		
	// 	length = document.getElementById('expandedNoteText').innerHTML.replace(/\<br\>/g, "\n").length
	// }
	
	switch(theClickedThing.id){
		case "expandedNote":
			length = $('#expandedNoteText').innerHTML.replace(/\<br\>/g, "\n").length
			gotoIndex = parseInt(theClickedThing.getAttribute("data-line"))		
			goto(gotoIndex, theClickedThing, (length + 5))
			return
		case "trashNote":
			length = $('#expandedNoteText').innerHTML.replace(/\<br\>/g, "\n").length
			gotoIndex = theClickedThing.parentNode.parentNode.getAttribute("data-line")
			goto(gotoIndex, theClickedThing, (length + 5), "#bb8888")
			// Beat.call("Beat.timer(1.75, function(){Beat.replaceRange(" + (parseInt(gotoIndex)) + ", " + (length + 4) + ", '')})")
			Beat.call("Beat.custom.deleteNote(" + (parseInt(gotoIndex)) + ", " + (length + 5) + ")")
				// perhaps put this as a function in the plugin instead, and add if both previous and next line are empty then delete one of them
			return
		case "cover": 
			if (settingsContainerVisibility==1){
				toggleSettingsContainer()
			}
		case "buttonRow":
			if ($id("menu")){
				$id("menu").remove()
			}
			$id("printbox")?.remove()
			// if (trackingContainerVisibility==1){
				toggleTrackingContainer(true)
			// }
			return
		case "flexiContainer":
			if($(".wider"))makeWider($(".wider"))
	}

	//ADDED TO FIX WHAT CONSIDERS CLICKED when in Index Card Mode
	//this is redundant now, right?
		if (indexCardMode && [...theClickedThing.classList].includes("synopsiscontainer")){
			while(theClickedThing.parentNode 
				&& 
				(![...theClickedThing.classList].includes("scene") && ![...theClickedThing.classList].includes("section")))
				{
				theClickedThing = theClickedThing.parentNode
			}
		}
		// if (indexCardMode == 2 && [...theClickedThing.classList].includes("thisIsASynopsis")){
		// 	while(theClickedThing.parentNode && ![...theClickedThing.classList].includes("section")){
		// 		theClickedThing = theClickedThing.parentNode
		// 	}
		// }	

		//Yes: This is needed
		if (indexCardMode && [...theClickedThing.classList].includes("section")){
			while(theClickedThing.firstChild && ![...theClickedThing.classList].includes("section-heading")){
				theClickedThing = theClickedThing.firstChild
			}
		}
	
	collapseNote()
	
	if (rightClick || contextMenuIsOpen) {
			x = event.clientX
			y = event.clientY

		contextMenu(theClickedThing, x, y, rightClick)
		mylog("back from contexMenu() into SomethingWasClicked()")
		mylog("whereto?")
		return false
	}

	if (a.includes("section-heading")) {theClickedThing = theClickedThing.parentNode; a = [...theClickedThing.classList]}
	if (a.includes("sceneheading")) {theClickedThing = theClickedThing.parentNode; a = [...theClickedThing.classList]}

	if (event.metaKey){
		if (a.includes("isSelected")) {
			theClickedThing.classList.remove('isSelected')
			return
		}

		if (a.includes("scene") || a.includes("section") || a.includes("synopsis")) {theClickedThing.classList.add('isSelected')}
		return
	}

	if (event.shiftKey){
		let alreadySelectedElements = $$(".isSelected")
		if (alreadySelectedElements.length == 0){
				if ($id("youAreHere")) {
					let setCurrentElementToStartElement = $id("youAreHere").parentNode.id
					$id(setCurrentElementToStartElement).classList.add("isSelected")
				}else{
			theClickedThing.classList.add('isSelected')
			return
			}
		}

		let closestPredecessor = -1
		let closestSuccessor = -1
		let thisOne = Number(theClickedThing.id)

		for (element of alreadySelectedElements){
			a = Number(element.id)

			if (a < thisOne){closestPredecessor = a;}
			if (a > thisOne){closestSuccessor = a; break}
		}

		if (closestPredecessor < 0) {

			for (i = thisOne; i <= closestSuccessor; i++){
				let selectThis = $id(i)
				if (selectThis){
					if (![...selectThis.classList].includes("dimmedScene") && ![...selectThis.classList].includes("dimmedSection") && ![...selectThis.classList].includes("synopsis")){
						if (!(areScenesProportional == 1 && [...selectThis.classList].includes("isOmitted"))){
							selectThis.classList.add('isSelected')
						}
					}
				}
			}
		}else{
			for (i = closestPredecessor; i <= thisOne; i++){				
				let selectThis = $id(i)
				if (selectThis){
					if (![...selectThis.classList].includes("dimmedScene") && ![...selectThis.classList].includes("dimmedSection") && ![...selectThis.classList].includes("synopsis")){
						if (!(areScenesProportional == 1 && [...selectThis.classList].includes("isOmitted"))){
							selectThis.classList.add('isSelected')
						}
					}
				}
			}
		}
		return
	}

	deselectAllElements()

	//Finally: if the clicked thing was an outline element, let's go there!

	if([...theClickedThing.classList].includes('note')){	
		length = theClickedThing.innerHTML.replace(/\<br\>/g, "\n").length + 5
	}
	if (theClickedThing.classList.contains("review")){
		expandReview(theClickedThing)
		length = parseInt(theClickedThing.getAttribute("data-length")) + 1
	}else{
		expandReview()
	}


	if (a.includes("revision")){

		length = theClickedThing.dataset.length + 1
		
	}

	if(theClickedThing.classList.contains('scene') || theClickedThing.classList.contains('sceneheading') || theClickedThing.classList.contains('synopsis') ){
		theClickedThing.classList.add('isSelected')
	} //because every click also counts as a first selection
	if(theClickedThing.classList.contains("section-heading") || theClickedThing.classList.contains("section")){
		theClickedThing.closest(".section").classList.add("isSelected")
	}

	// setTimeout(makeWider(theClickedThing),210)

	mylog("end of sthWasClicked -- " + theClickedThing.classList)

	if (gotoIndex) {goto(gotoIndex, theClickedThing, length)}
	mylog("now returning")
}

function makeWider(theClickedThing, cycledWithKey, shift){

		theRoot.style.setProperty('--wider-width', $$(".level1").length/2);


		if (theClickedThing && theClickedThing.closest(".level1").classList.contains("wider")){
			let allWidened = $$(".wider")
			allWidened.forEach(element => {
				element.classList.remove("wider")
			})
			return
		}
	
		// let allActs = $$(".level1")
		// if(!theClickedThing?.classList.contains("editBox")){
		// 	allActs.forEach(element => {
		// 		element.classList.remove("wider")
		// 	})
		// }
		// let theSelection = $$(".isSelected")

		if (theClickedThing) {
			$(".wider")?.classList.remove("wider")
			theClickedThing.closest(".level1").classList.add("wider")
			return
		}
		// if(indexCardMode && theSelection.length == 1 && (
		// 	theSelection[0].classList.contains("section") ||
		// 	theSelection[0].classList.contains("synopsis") ||
		// 	theSelection[0].classList.contains("scene")
		// )){
		// 	theSelection[0].closest(".level1").classList.add("wider")
		// }

		if (!cycledWithKey) return

		let allActs = $$(".level1")
		let currentlyWidened = $(".wider") || null
			if(allActs.length = 0)return

		if(currentlyWidened && $(".isSelected")){
			$(".wider").classList.remove("wider")
			return
		}
	
		let value = [].indexOf.call(allActs, currentlyWidened)

		value += (shift ? -1 : 1) 
			if(value < -1)value = allActs.length - 1
			if(value > allActs.length - 1)value =  - 1
			// if(!currentlyWidened && $(".isSelected")){
			if($(".isSelected")){
				value = [].indexOf.call(allActs, $(".isSelected").closest(".level1"))
			}

		currentlyWidened?.classList.remove("wider")
		if(value > -1) allActs[value].classList.add("wider")

			
			// for (let i = 0; i < allActs.length; i++){
			// 	if (allActs[i].classList.contains("wider")) break
			// }
		
			// allActs[i].classList.remove("wider")

			// i++
			// if (i > allActs.length) i = 0
			// allActs[i].classList.add("wider")

		// }
	}

function walkTheOutline(e){

	mylog()
	closeContextMenu()

	let direction = (e.key == "ArrowDown") ? 1 : -1

	mylog(direction)

	let selectedElements = $$(".isSelected")
	let startingElement
		if (selectedElements.length > 0){
			mylog("length was > 0")
			startingElement = selectedElements[0]
			if (selectedElements.length > 1){
				if (direction == 1) startingElement = selectedElements[selectedElements.length -1]
			}
		}else{
			mylog("length was <= 0")
			if(!$id("youAreHere")) return
			mylog("but there was a you are here?")
			let elementNumber = Number($id("youAreHere").getAttribute('data-outlineElementCount'))
			startingElement = $id(elementNumber)
		}

	let gotoElement = Number(startingElement.id) + direction
		while (outline[gotoElement + direction] && outline[gotoElement].typeAsString == "Synopse") {gotoElement = gotoElement + direction}

		let allScenesOrSections = $$(".section, .scene")
			lastSceneOrSection = allScenesOrSections[allScenesOrSections.length - 1]
		if(gotoElement < 0 || gotoElement > Number(lastSceneOrSection.id)){return}

	if(!e.shiftKey)deselectAllElements()

	$id(gotoElement).classList.add("isSelected")
		let gotoIndex = $id(gotoElement).getAttribute("data-line")
		let theClickedThing = $id(gotoElement)
		let length = outline[gotoElement].line.string.length + 1
		let blinkColor = theClickedThing.style.backgroundColor

	mylog("now goto")
	goto(gotoIndex, theClickedThing, length, blinkColor)


}

function __________TOGGLERS(){}

	function advancedTogglers(classToToggle, buttonId, absolute){

	flexiContainer.classList.toggle(classToToggle)
	$id(buttonId).checked = flexiContainer.classList.contains(classToToggle)

	if(classToToggle=="dualSectionLines")recalculateHeights()

	saveCurrentState()

}

function setSharedScreen(){

	let availHeight = window.screen.availHeight
	let availWidth = window.screen.availWidth

	Beat.call(`Beat.custom.makeWindowsShareScreen(${availHeight}, ${availWidth})`)

}

function toggleFullScreen(){

	isFullScreen = !isFullScreen

	Beat.call(`Beat.custom.toggleFull()`)
	// Beat.call(`Beat.htmlWindow.toggleFullScreen()`)

}

function toggleExcludeVoiceOvers(){

	userDefault.excludeVoiceOvers = !userDefault.excludeVoiceOvers

	saveCurrentState()
	
	updateFilter()
	//collectCharacters()
	
	setAllButtons()

}

function toggleIncludeSynopsis(){

	documentSetting.trackingIncludesSynopsis = !documentSetting.trackingIncludesSynopsis

	saveCurrentState()

	updateFilter()
	//collectCharacters()

	setAllButtons()

}

function toggleMultipleSceneLines(){

	documentSetting.showMultipleSceneLines = !documentSetting.showMultipleSceneLines
	flexiContainer.classList.toggle("dualSceneLines", documentSetting.showMultipleSceneLines)
	setAllButtons()
	saveCurrentState()

}

function toggleInvertText(){

invertTextOnDark = !invertTextOnDark
weAreChangingColors = true
startSmallUpdate()
setAllButtons()
saveCurrentState()

}

function toggleOneColumnOutline() { 
	mylog("toggleOneColumnOutline")
	oneColumnOutline = 1 - oneColumnOutline;
	document.getElementById("flexiContainer").style.display = flexOrInLineBlock[oneColumnOutline]
	$id("flexiContainer").classList.toggle("oneColumnOutline", oneColumnOutline)
	
	setAllButtons()
	saveCurrentState()
	recalculateHeights("from ToggleOneColumnOutline") // or else, in index card mode, cards get the wildest sizes.

	if(notesAreDisplayed){toggleDisplayNotes(); toggleDisplayNotes()}
	if(markersAreDisplayed){toggleDisplayMarkers(); toggleDisplayMarkers()}
	if(beatsAreDisplayed){toggleDisplayBeats(); toggleDisplayBeats()}
	if(reviewsAreDisplayed){toggleDisplayReviews(); toggleDisplayReviews()}
}
	
function toggleDebugContainer() { 
	mylog("toggleDebugContainer")
	debugContainerVisibility=1-debugContainerVisibility;
	if (debugContainerVisibility == 1) {
		debugContainer.style.display = "block";
		debugContainer.innerHTML = logArray.join("<br/>")
	}else {
		debugContainer.style.display = "none";
	}
}

function toggleIndexCardMode(firstrun){
	mylog("toggleIndexCardMode")

	//remember to 1. set all indexCardmode to true or false, and 
	// 				2. transform on open from 1/2 to true

	mylog("entering toggleIndex..." + indexCardMode)
	indexCardMode = !indexCardMode
	
	if(!firstrun){ // will allow changing in spite of empty flexicontainer when opening doc and restoring mode!
		if($$(".scene").length == 0 && $$(".section").length == 0){indexCardMode = false}
	}

	if (indexCardMode) {

			mylog("indexCards ON")

			if($(".hideSlugIfSmall")){
				mylog("YES TO HIDE SLUG")
				let smalls = $$(".hideSlugIfSmall")
				for (small of smalls){
					mylog ("REMOVING")
					small.classList.remove("hideSlugIfSmall")
				}
			}

			scenesWereProportionalBeforeIndexMode = (areScenesProportional == 1) ? true : false
				areScenesProportional = 0
				document.getElementById("flexiContainer").classList.remove("nonProportionalMode")
						
			//document.getElementById("indexCardButton").classList.add("buttonIsActive")
			document.getElementById("flexiContainer").classList.add("indexcards")
			// document.getElementById("flexiContainer").classList.remove("showSynopsisInScenes")
			document.getElementById("indexCardButton").innerHTML = newIndexCardIcon
			
	}else{

			mylog("indexCards OFF")
			
			document.getElementById("indexCardButton").classList.remove("buttonIsActive")
			document.getElementById("flexiContainer").classList.remove("indexcards")

			//hacky way to turn back prop to where it was and have icon redraw. 
			toggleProportional()
			if (!scenesWereProportionalBeforeIndexMode){
				mylog("turning proportional back on when leaving index card mode")
				toggleProportional()}

	}

	setAllButtons()
	youAreHere()
	recalculateHeights("from toggleIndexCardMode")
	saveCurrentState()
	reevaluateColorContrast()

	if(notesAreDisplayed){toggleDisplayNotes(); toggleDisplayNotes()}
	if(markersAreDisplayed){toggleDisplayMarkers(); toggleDisplayMarkers()}
	if(beatsAreDisplayed){toggleDisplayBeats(); toggleDisplayBeats()}
	if(reviewsAreDisplayed){toggleDisplayReviews(); toggleDisplayReviews()}

	mylog("end cycling index card mode")
}
	
function toggleShowSceneNumbers() {
	mylog("toggleShowSceneNumbers")
	if (whatAreSceneNumbers == "inline") {
		theRoot.style.setProperty('--showSceneNum', 'none');	
		}else{
		theRoot.style.setProperty('--showSceneNum', 'inline');	
		}
		
	whatAreSceneNumbers = theRoot.style.getPropertyValue('--showSceneNum');
	setAllButtons()
	saveCurrentState()
}

function toggleShowPageNumbers() {
	mylog("toggleShowPageNumbers")
	if (whatArePageNumbers == "inline") {
		theRoot.style.setProperty('--showPageNum', 'none');	
		}else{
		theRoot.style.setProperty('--showPageNum', 'inline');	
		saveCurrentState()
	}
		
	whatArePageNumbers = theRoot.style.getPropertyValue('--showPageNum');
	recalculateHeights()
	setAllButtons()
}

function toggleShowSceneLength() {
	mylog("toggleShowSceneLength")
	if (whatAreSceneLengths == "inline") {
		theRoot.style.setProperty('--showSceneLength', 'none');	
		}else{
		theRoot.style.setProperty('--showSceneLength', 'inline');	
	}
		
	whatAreSceneLengths = theRoot.style.getPropertyValue('--showSceneLength'); //double-check: Do I still use this?
	setAllButtons()
	saveCurrentState()
}

function toggleWarnings() {
	mylog("toggleWarning")
	warningsAreOn = warningsAreOn ? false : true
		
	setAllButtons()
	saveCurrentState()
}

function toggleShowRevisions() {

	mylog(" from " + documentSetting.showRevisions)

	documentSetting.showRevisions = (documentSetting.showRevisions === false)

	if(documentSetting.showRevisions){
		collectRevisionIndices()
	}else{
		let currentDivs = $$(".revision")
		if(currentDivs.length > 0){
			currentDivs.forEach(element => {
				element.remove()
			});
		}
	}
	
	setAllButtons()
}

function toggleDisplayNotes() {
	mylog("toggleDisplayNotes")
	notesAreDisplayed = (notesAreDisplayed == false)
		
	if(notesAreDisplayed){
		collectNotes("toggleDisplayNotes")
	}else{
		collapseNote()
		let noteElements = document.getElementsByClassName("noteContainer")
		
		for (i = noteElements.length-1; i > -1; i--) {
			noteElements[i].remove()
		}
	}
	setAllButtons()
	//saveCurrentState()
}

function toggleDisplayMarkers() {
	mylog("toggleDisplayMarkers")
	markersAreDisplayed = (markersAreDisplayed == false)
	
	
	if(markersAreDisplayed){
		document.getElementById("flexiContainer").classList.add("markersAreDisplayed")
		collectNotes("toggleDisplayMarkers")
	}else{
		document.getElementById("flexiContainer").classList.remove("markersAreDisplayed")
		let currentMarkers = document.querySelectorAll(".marker")
        for (currentMarker of currentMarkers){currentMarker.remove()}
	}
	setAllButtons()
	//saveCurrentState()
}

function toggleDisplayReviews() {

	mylog()
	reviewsAreDisplayed = (reviewsAreDisplayed == false)

	if(reviewsAreDisplayed){
		flexiContainer.classList.add("reviewsAreDisplayed")
		collectReviews()
	}else{
		flexiContainer.classList.remove("reviewsAreDisplayed")
		let existingReviews = $$(".review")
		for (existingReview of existingReviews){existingReview.remove()}
	}

	setAllButtons()

}

function toggleDisplayBeats() {
	mylog("toggleDisplayBeats")
	beatsAreDisplayed = (beatsAreDisplayed == false)
	
	if(beatsAreDisplayed){
		$("#flexiContainer").classList.add("beatsAreDisplayed")
		collectNotes("toggleDisplayBeats")
	}else{
		$("#flexiContainer").classList.remove("beatsAreDisplayed")
		let currentBeats = $$(".beat")
        for (currentBeat of currentBeats){currentBeat.remove()}
		let currentPaths = $$(".svgForBeats")
		for (currentPath of currentPaths){currentPath.remove()}
	}
	setAllButtons()
	//saveCurrentState()
	mylog("end of toggling Beats")
}

function toggleDisplaySynopsis() {
	mylog("toggleDisplaySynopsis")
	if ($id("flexiContainer").classList.contains("indexcards")){return}
	document.getElementById("flexiContainer").classList.toggle("showSynopsisInScenes")
	setAllButtons()
}
	
function toggleSettingsContainer() { 
	mylog("toggleSettingsContainer")

	if (trackingContainerVisibility == 1){toggleTrackingContainer()}
	if (helpContainerVisibility == 1){toggleHelpContainer()}

	settingsContainerVisibility = 1 - settingsContainerVisibility;
	settingsContainer.style.display = blockOrNone[1-settingsContainerVisibility];
	coverContainer.style.display = blockOrNone[1-settingsContainerVisibility];
}

function toggleHelpContainer() {
	mylog("toggleHelpContainer")

	closeNewMenu()

	if (trackingContainerVisibility == 1){toggleTrackingContainer()}
	if (settingsContainerVisibility == 1){toggleSettingsContainer()}

	helpContainerVisibility = 1 - helpContainerVisibility;
	helpContainer.style.display = blockOrNone[1-helpContainerVisibility];
	coverContainer.style.display = blockOrNone[1-helpContainerVisibility];
}

function toggleTrackingContainer(close) { 
	mylog("toggleTrackingContainer")

	if (settingsContainerVisibility == 1){toggleSettingsContainer()}
	if (helpContainerVisibility == 1){toggleHelpContainer()}
	$id("aboutBox")?.remove()
	$("#textContainer")?.remove()

	if($id("menu")){$id("menu").remove()}

	trackingContainerVisibility = 1 - trackingContainerVisibility;
		if(close){trackingContainerVisibility = 0}

	if (trackingContainerVisibility == 1) {collectCharacters()}
	trackingContainer.style.display = blockOrNone[1-trackingContainerVisibility];
	coverContainer.style.display = blockOrNone[1-trackingContainerVisibility];
}

function toggleColorScheme() { 
	mylog("toggleColorScheme")

	colorScheme = 'FTOutlinerBeat'.replace(colorScheme, "")
	document.documentElement.setAttribute('data-theme', colorScheme)
	
	setAllButtons()
	saveCurrentState()
	reevaluateColorContrast()
}

function outdoorMode(){

	mylog(outdoor)

	outdoor = 1 - outdoor
	document.documentElement.setAttribute('data-outdoors', outdoor)
	setAllButtons()


}
	
function toggleProportional(absolute) { 
	mylog("toggleProportional")

	if(indexCardMode){
		toggleIndexCardMode(); 
		if(!absolute){
			return
		}
	}

	if(absolute){ //set to opposite value and then toggle with the rest of the code
		if (absolute == "on"){areScenesProportional = 0}
		else {areScenesProportional = 1}	
	}

	areScenesProportional = 1 - areScenesProportional;
	theRoot.style.setProperty('--proportionalScenes', areScenesProportional);
	// document.getElementById("buttonForProportional").checked = (areScenesProportional == 1);

	if(areScenesProportional == 1){

		document.getElementById("flexiContainer").classList.remove("nonProportionalMode")
		document.getElementById("indexCardButton").innerHTML = outlineIcon

	}
	else
	{
		document.getElementById("flexiContainer").classList.add("nonProportionalMode")
		document.getElementById("indexCardButton").innerHTML = fixedIcon
	
		let scenes = $$(".scene")
		for (let scene of scenes){
			scene.classList.remove("hideSlugIfSmall")
		}
	}

	if (notesAreDisplayed){
		toggleDisplayNotes()
		toggleDisplayNotes()
	}

	if (markersAreDisplayed){
		toggleDisplayMarkers()
		toggleDisplayMarkers()
	}

	if (beatsAreDisplayed){
		toggleDisplayBeats()
		toggleDisplayBeats()
	}

	if (reviewsAreDisplayed){
		toggleDisplayReviews()
		toggleDisplayReviews()
	}

	// if (flexiContainer.classList.contains("showSynopsisInScenes")){
	// 	toggleDisplaySynopsis()
	// 	toggleDisplaySynopsis()
	// }


	mylog("In toggleProportional, before RecalculateHeights()")
	recalculateHeights("from ToggleProportional")

	mylog("Scenes are proportional: " + areScenesProportional)

	setAllButtons()
	saveCurrentState()
	reevaluateColorContrast()
}

function toggleRealTime() { 
	mylog("toggleRealTime")
	isRealTimeOn = 1 - isRealTimeOn;
	setAllButtons()
}

function addShowHideBoneyard(){

	if(!$(".boneyard")){

		let doThis = `Beat.addString(\"\\n#BONEYARD\\n\\n===\\n\\n\", Beat.getText().length)`
		Beat.call(doThis)
		flexiContainer.classList.remove("boneyardIsClosed")
		return
	}

	flexiContainer.classList.toggle("boneyardIsClosed")
	setAllButtons()

}

function __________ACTIONS(){}

function goto(gotoIndex, theClickedThing, length, blinkColor){

	mylog("goto " + gotoIndex)

	let classes = [...theClickedThing.classList]
	if (classes.includes("sceneheading") || classes.includes("scene") || classes.includes("section") || classes.includes("synopsis")){
		Beat.call("Beat.scrollToScene(Beat.currentParser.sceneAtIndex(" + gotoIndex + "))")
	}
		
	if (classes.includes("showActLength")){gotoIndex ++}
	gotoIndex = Math.min(gotoIndex, absoluteTextLength - 1)
	
	Beat.call("Beat.scrollTo(" + gotoIndex + ")") 
		
		//for debugging purposes: Selects entire scene object if clicking it
			// if (a.includes("sceneheading") || a.includes("section") || a.includes("thisIsASynopsis")){
			// Beat.call("Beat.setSelectedRange(" + gotoIndex + "," + outline[theClickedThing.getAttribute("data-elementCount")].sceneLength + ")")
			// }

	if (classes.includes("pageDivider")) return

	let elementColor = window.getComputedStyle(theClickedThing).backgroundColor
	let textColor
	if ((classes.includes("scene") || classes.includes("revision")) && elementColor){
		let values = elementColor.replace(/rgb(a)*\(/, "").replace(")", "").split(",")
		let rgbAsHex = ""
		for (value of values){
			if (rgbAsHex.length == 6){break}
			let thisvalue = Number(value).toString(16).toUpperCase()
			thisvalue = thisvalue.length > 1 ? thisvalue : "0" + thisvalue
			rgbAsHex += thisvalue
		}
		blinkColor = "#" + rgbAsHex
		textColor = "#222222"
	}

	if (classes.includes("note") || classes.includes("expandedNote") || classes.includes("notepanelNote")){
		blinkColor = "#cccc55"

		if(classes.includes("notepanelNote")){
			let noteNumber = theClickedThing.id.substring("notepanelNote".length)
			mylog("this is note: ------------------------------------------------- " + noteNumber)
			// mylog(globalNotesData[noteNumber].string.replace(/\<br\/\>/g, "_"))
			length = globalNotesData[noteNumber].string.replace(/\<br\/\>/g, "_").length + 1
		}
	}

	blinkColor = blinkColor || "#888888"
	textColor = textColor || false
	//Beat.call("Beat.alert('" + length + "','" + theClickedThing.classList + "')")

	let blinkLength = length || "Beat.currentParser.lineAtIndex(" + gotoIndex + ")?.string?.length + 1"
	Beat.call("Beat.custom.blinkTheLine(" + gotoIndex + "," + blinkLength + ", '" + blinkColor + "' , '" + textColor + "');")
		
		// //This previouse selected a clicked note -- temporarily disabled because blinking is enough?
			// if ([...theClickedThing.classList].includes("note") || theClickedThing.id == "expandedNote"){
			// 	if (theClickedThing.id != "expandedNote"){
			// 		length = theClickedThing.innerHTML.replace(/\<br\>/g, "\n").length
			// 	}
			// 	Beat.call("Beat.setSelectedRange(" + (parseInt(gotoIndex) + 2) + ", " + length + ")")
			// }
}

function selectAllElements(altWasPressed) {
	mylog("selectAllElements")
	let allElements = $$(".scene, .section")
	for (element of allElements){

		let docontinue = false

		if (![...element.classList].includes("dimmedScene") && ![...element.classList].includes("dimmedSection")){
			if(altWasPressed && [...element.classList].includes("section")){docontinue = true}

			
			if([...document.getElementById("flexiContainer").classList].includes("uncolorAllScenesBut")){
				docontinue = true
				for (let color of colorsArray){
					if([...document.getElementById("flexiContainer").classList].includes(color.toLowerCase()) && [...element.classList].includes(color.toLowerCase())){
						docontinue = false
					}
				}
			}

		if (docontinue){continue}
		element.classList.add("isSelected")
		}
	}
}

// Below is a function stolen from https://davidwalsh.name/javascript-debounce-function

// Returns a function, that, as long as it continues to be invoked, will not be triggered. 
// The function will be called after it stops being called for N milliseconds. 
// If `immediate` is passed, trigger the function on the leading edge, instead of the trailing.

function debounce(func, wait, immediate) { 
	//currently only used from somoneResizedTheWindow()
	
	var timeout;
	return function() {
		var context = this, args = arguments;
		var later = function() {
			timeout = null;
			if (!immediate) func.apply(context, args);
		};
		var callNow = immediate && !timeout;
		clearTimeout(timeout);
		timeout = setTimeout(later, wait);
		if (callNow) func.apply(context, args);
	};
}

function changeIndexCardHeight(key){

	switch (key){
		case "=":
		case "+":
			//indexCardHeight = Math.min(4.5, Number(indexCardHeight) + 0.25) 
			indexCardHeight = Math.min(20, Number(indexCardHeight) + 1) 
		break;
		case "-":
			//indexCardHeight = Math.max(0.5, Number(indexCardHeight) - 0.25) 
			indexCardHeight = Math.max(0, Number(indexCardHeight) - 1) 
		break;
		case "0":
			indexCardHeight = 5
	}

	recalculateHeights("from changeIndexCardHeight")
	saveCurrentState()

	if (notesAreDisplayed){displayNotes()}
}

function zoomSizes(key){

	currentZoomLevel = getComputedStyle(theRoot).getPropertyValue('--fontSizeFactor')

	switch (key){
		case "=":
		case "+":
			newZoomLevel = Math.min(2, Number(currentZoomLevel) + 0.2) 
		break;
		case "-":
			newZoomLevel = Math.max(0.4, Number(currentZoomLevel) - 0.2) 
		break;
		case "0":
			newZoomLevel = 1
	}

	theRoot.style.setProperty('--fontSizeFactor', newZoomLevel)
	currentZoomLevel = newZoomLevel

	setTimeout(() => {
		
		recalculateHeights("from zoomSizes")
	}, 300);
	saveCurrentState()

	if (notesAreDisplayed){displayNotes()}

}

function isThisOffScreen(element){

	mylog("=====================")
	mylog("======== determining off/onscreen for..." + element?.classList)
	mylog("=====================")

	if(!element) return

	let rect = element.getBoundingClientRect()

	// mylog("this is the element's measurements:")
	// mylog("rightmost point: " + (rect.x + rect.width))
	// mylog("topmost point: " + (rect.y))
	// mylog("window width: " + window.innerWidth)
	// mylog("window height: " + window.innerHeight)
	

	return (
		(rect.x + rect.width) < 0 
            || 
		(rect.y) < 20
            || 
		(rect.x > window.innerWidth 
			|| 
		rect.y + rect.height > (window.innerHeight - 70))
	)
}

function scrollNicelyIntoView(element){

	mylog("scrollNicely")

	if(weAreCurrentlyEditingText){return}

	//OLD JS METHOD
		// location.hash = "#" + element.id
		// return

	//Webkit 15.4
		// element.scrollIntoView(smooth, center)
		// return

		let elementRect = element.getBoundingClientRect()
		let frameRect = document.getElementById("flexiContainer").getBoundingClientRect()
		let currentScroll = document.getElementById("flexiContainer").scrollTop
		let currentBottom = frameRect.height + currentScroll

		
		let oldPos = elementRect.top
		let targetPos = currentScroll + oldPos - frameRect.bottom/2


		let diff = (targetPos - currentScroll) / 10
		let newPos = currentScroll

		if (targetPos > currentScroll){
			function stepUp() {
				newPos = newPos + diff
				document.getElementById("flexiContainer").scrollTo(0, newPos)

				if (newPos < targetPos) {
					mylog("animating UP")
					window.requestAnimationFrame(stepUp)
				}
			}
			window.requestAnimationFrame(stepUp)
		}

		if (targetPos < currentScroll){
			function stepDown() {
				newPos = newPos + diff
				document.getElementById("flexiContainer").scrollTo(0, newPos)

				if (newPos > targetPos) {
					mylog("animating DOWN")
					window.requestAnimationFrame(stepDown)
				}
			}
			window.requestAnimationFrame(stepDown)
		}
	
	mylog("scrollNicely is now done")
}

function __________ALERTS_AND_LOGS(){}

function alertThis(first, second){
	Beat.call("Beat.alert(`" + first + "`, `" + second + "`)")
}

function toggleConsole(){

	loggingIsOn = !loggingIsOn
	if($id("buttonForLogging")){$id("buttonForLogging").checked = loggingIsOn}

	flexiContainer.classList.toggle("loggingIsOn", loggingIsOn)

	if(loggingIsOn){Beat.call("Beat.openConsole()")}

}

// function mylog(text, noError, important, sameline){
function mylog(text, isError){

	text = JSON.stringify(mylog.caller.name).substr(1, mylog.caller.name.length) + ":      " + (text || "--------------------")

	if(loggingIsOn){
		let log = "Beat.log(`" + text + "`)"
		Beat.call(log)
	}

	logArray.push(new Date().toISOString() + " -- " + text)
		while (logArray.length > 50){logArray.shift()}

	if(!isError){return}

		Beat.log(" ")
		Beat.log(" ")
		Beat.log(" ")
		Beat.log(JSON.stringify(mylog.caller?.caller?.name) + " > " + JSON.stringify(mylog.caller?.name))
		Beat.log("*******************************")
		Beat.log("* ========== ERROR ========== *")
		Beat.log("*******************************")
		Beat.log(" ")
		displayErrorMessage(logArray)

}

</script>

<!-- <style>
	.scene::after{

position: absolute;
top: 0;
left: 0;
content: attr(data-line) "," attr(data-line-end);
background-color: red;
color: white;


	}
</style> -->