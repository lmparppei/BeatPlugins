/*: 
Emotional Journey
Copyright: Jürgen Heimüller 2025

Plugin Type: Tool
Version: 1.3

Description: This plugin creates interactive emotion charts showing emotional journeys of characters or storylines throughout your script. Track emotional highs and lows, compare multiple characters, storylines, and visualize dramatic arcs with precision.
Image: screenshot.jpg
*/

let myWindow = null;
let isPluginVisible = false;
let updateTimer = null;

// Settings mit Fallbacks
const savedLineStyle = Beat.getDocumentSetting("lineStyle");
let lineStyle = "round";
if (savedLineStyle && ["round", "straight", "square"].includes(savedLineStyle)) {
  lineStyle = savedLineStyle;
}

let hiddenCharacters = new Set();

// --- API for UI -> Plugin
if (typeof Beat.custom === 'undefined') {
    Beat.custom = {};
}

Beat.custom.moveToLine = function(lineIndex, markerStart, markerLength) {
  try {
    const lines = Beat.lines();
    if (lineIndex >= 0 && lineIndex < lines.length) {
      const line = lines[lineIndex];
      
      if (line.position !== undefined) {
        if (typeof Beat.scrollTo === "function") {
          Beat.scrollTo(line.position);
        }
        
        if (typeof Beat.setSelectedRange === "function") {
          const safeMarkerStart = Number(markerStart) || 0;
          const safeMarkerLength = Number(markerLength) || 0;
          
          if (safeMarkerStart > 0 && safeMarkerLength > 0) {
            const selectionStart = line.position + safeMarkerStart;
            Beat.setSelectedRange(selectionStart, safeMarkerLength);
          } else {
            Beat.setSelectedRange(line.position, 0);
          }
        }
      }
    }
  } catch (e) {
    Beat.log("moveToLine error: " + e);
  }
};

Beat.custom.updateHiddenCharacters = function(chars) {
  hiddenCharacters = new Set(chars);
  Beat.setDocumentSetting("hiddenChars", Array.from(hiddenCharacters));
};

Beat.custom.updateLineStyle = function(style) {
  if (["round", "straight", "square"].includes(style)) {
    lineStyle = style;
    Beat.setDocumentSetting("lineStyle", lineStyle);
  }
};

// --- Text Change Listener for Live Updates
Beat.onTextChange(function(loc, len) {
  if (updateTimer != null) updateTimer.invalidate();
  
  updateTimer = Beat.timer(1.5, function() {
    if (myWindow && isPluginVisible) {
      const parsed = collectEmotions();
      const hasData = parsed && Object.keys(parsed.dataByChar).length > 0;
      const html = buildHTML(parsed, hasData);
      myWindow.setHTML(html);
    }
    updateTimer = null;
  });
});

// --- Main Functions
function main() {
  const parsed = collectEmotions();
  const hasData = parsed && Object.keys(parsed.dataByChar).length > 0;
  
  // Hidden Characters nur laden wenn Daten vorhanden
  let savedHiddenChars = Beat.getDocumentSetting("hiddenChars") || [];
  hiddenCharacters = new Set();
  
  if (hasData && parsed && parsed.dataByChar) {
    const currentCharacters = Object.keys(parsed.dataByChar).map(name => 
      capitalizeName(parsed.dataByChar[name][0]?.originalName || name)
    );
    
    savedHiddenChars.forEach(char => {
      if (currentCharacters.includes(char)) {
        hiddenCharacters.add(char);
      }
    });
  }
  
  const html = buildHTML(parsed, hasData);
  
  // Unterschiedliche Default-Größen je nach Daten-Vorhandensein
  const defaultWidth = hasData ? Math.round(600) : 600;
  const defaultHeight = hasData ? Math.round(600) : 500;
  
  myWindow = Beat.htmlWindow(html, defaultWidth, defaultHeight, onWindowClosed);
  myWindow.disableMaximize = true;
  myWindow.disableFullScreen = true;
  myWindow.disableMinimize = true;
  
  const savedSize = Beat.getDocumentSetting("windowSize");
  const savedPos = Beat.getDocumentSetting("windowPosition");
  
  let [x, y, maxWidth, maxHeight] = Beat.screen();

  let windowWidth = defaultWidth;
  let windowHeight = defaultHeight;

  // Nur gespeicherte Größe verwenden WENN Daten vorhanden sind
  if (hasData && savedSize) {
    windowWidth = Math.min(Math.max(savedSize.width, 400), maxWidth);
    windowHeight = Math.min(Math.max(savedSize.height, 300), maxHeight);
  }

  let windowX = 100;
  let windowY = 100;

  if (hasData && savedPos) {
    windowX = Math.max(0, Math.min(savedPos.x, maxWidth - windowWidth));
    windowY = Math.max(0, Math.min(savedPos.y, maxHeight - windowHeight));
  } else {
    // Zentriere das Fenster wenn keine Daten oder keine gespeicherte Position
    windowX = (maxWidth - windowWidth) / 2;
    windowY = (maxHeight - windowHeight) / 2;
  }

  myWindow.setFrame(windowX, windowY, windowWidth, windowHeight);
  myWindow.show();
  isPluginVisible = true;
}

function onWindowClosed() {
  if (myWindow) {
    const frame = myWindow.getFrame();
    const [x, y, maxWidth, maxHeight] = Beat.screen();
    
    if (frame.width > 100 && frame.height > 100 && 
        frame.width <= maxWidth && frame.height <= maxHeight &&
        frame.x >= 0 && frame.y >= 0 &&
        frame.x <= maxWidth && frame.y <= maxHeight) {
      
      Beat.setDocumentSetting("windowSize", { 
        width: Math.max(400, frame.width), 
        height: Math.max(300, frame.height) 
      });
      Beat.setDocumentSetting("windowPosition", { 
        x: Math.max(0, frame.x), 
        y: Math.max(0, frame.y) 
      });
    }
  }
  
  isPluginVisible = false;
  try { Beat.end(); } catch (e) { /* ignore */ }
  myWindow = null;
  hiddenCharacters.clear();
}

// --- Helper Functions
function capitalizeName(name) {
  if (!name) return name;
  return name.split(' ')
    .map(function(word) {
      return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
    })
    .join(' ');
}

// --- Parser Helpers
function parsePairs(text) {
  const out = [];
  if (!text) return out;
  
  const regex = /@([a-zA-ZäöüßÄÖÜ\s]+)\s*=\s*([+-]?\d+)/gi;
  let match;
  
  while ((match = regex.exec(text)) !== null) {
    const name = match[1];
    const val = parseInt(match[2]);
    
    const numberPosInMatch = match[0].indexOf(match[2]);
    const numberStart = match.index + numberPosInMatch;
    const numberLength = match[2].length;
    
    if (!isNaN(val)) {
      out.push([name, val, numberStart, numberLength]);
    }
  }
  
  return out;
}

function combineConsecutiveSections(sectionMarkers) {
  if (sectionMarkers.length <= 1) return sectionMarkers;
  
  const combined = [];
  let currentGroup = [sectionMarkers[0]];
  
  for (let i = 1; i < sectionMarkers.length; i++) {
    const current = sectionMarkers[i];
    const lastInGroup = currentGroup[currentGroup.length - 1];
    
    if (current.x - lastInGroup.x <= 10) {
      currentGroup.push(current);
    } else {
      if (currentGroup.length > 1) {
        const combinedTitle = currentGroup.map(s => s.title).join(' / ');
        combined.push({
          x: Math.round(currentGroup.reduce((sum, s) => sum + s.x, 0) / currentGroup.length),
          title: combinedTitle,
          type: 'section',
          combined: true,
          level: currentGroup[0].level
        });
      } else {
        combined.push(currentGroup[0]);
      }
      currentGroup = [current];
    }
  }
  
  if (currentGroup.length > 1) {
    const combinedTitle = currentGroup.map(s => s.title).join(' / ');
    combined.push({
      x: Math.round(currentGroup.reduce((sum, s) => sum + s.x, 0) / currentGroup.length),
      title: combinedTitle,
      type: 'section',
      combined: true,
      level: currentGroup[0].level
    });
  } else {
    combined.push(currentGroup[0]);
  }
  
  return combined;
}

// --- Collect: Scenes + Markers + Sections
function collectEmotions() {
  const lines = Beat.lines();
  if (!lines || !lines.length) return null;

  const scenes = [];
  const sections = [];
  
  // Finde das Ende der Titelseite
  let scriptStartLine = 0;
  let inTitlePage = true;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    const str = String(line.string || "").trim();
    
    if (inTitlePage) {
      const isSceneHeading = /^\s*(INT|EXT|I\/E|INT\/EXT|EST)\b/i.test(str);
      const isSection = /^\s*#+\s/.test(str);
      const isActionOrCharacter = /^\s*[A-Z][A-Z\s]*$/.test(str) && str.length > 3 && !str.includes(':');
      
      if (isSceneHeading || isSection || isActionOrCharacter) {
        scriptStartLine = i;
        inTitlePage = false;
        break;
      }
    }
  }

  if (inTitlePage) scriptStartLine = 0;

  for (let i = scriptStartLine; i < lines.length; i++) {
    const line = lines[i];
    const str = String(line.string || "");
    
    const looksLikeHeading = /^\s*(INT|EXT|I\/E|INT\/EXT|EST)\b/i.test(str);
    if (looksLikeHeading) {
      const sceneNum = line.sceneNumber || (scenes.length + 1);
      scenes.push({ start: i, end: null, num: sceneNum, title: str.trim(), type: "scene" });
    }
    
    const sectionMatch = str.match(/^\s*(#+)\s*(.+?)\s*$/);
    if (sectionMatch) {
      const level = sectionMatch[1].length;
      const title = sectionMatch[2].trim();
      sections.push({ 
        start: i, 
        end: null, 
        title: title, 
        type: "section",
        level: level
      });
    }
  }
  
  if (scenes.length === 0) {
    scenes.push({ start: scriptStartLine, end: lines.length, num: 1, title: "", type: "scene" });
  } else {
    for (let s = 0; s < scenes.length; s++) {
      scenes[s].end = (s + 1 < scenes.length) ? scenes[s + 1].start : lines.length;
    }
  }
  
  const dataByChar = {};
  const sceneMarkers = scenes.map(s => ({ 
    x: s.start - scriptStartLine, 
    sceneNum: s.num, 
    type: "scene" 
  }));
  const sectionMarkers = sections.map(s => ({ 
    x: s.start - scriptStartLine, 
    title: s.title, 
    type: "section",
    level: s.level
  }));

  let lastMeaningfulSnippet = "";

  for (let i = scriptStartLine; i < lines.length; i++) {
    const line = lines[i];
    const str = String(line.string || "");

    let cleanLine = str;
    if (str.includes("/*")) cleanLine = str.substring(0, str.indexOf("/*")).trim();
    if (str.includes("//")) cleanLine = str.substring(0, str.indexOf("//")).trim();

    if (cleanLine.length > 0 && 
        !cleanLine.trim().startsWith("=") && 
        !cleanLine.trim().startsWith("[[")) {
      lastMeaningfulSnippet = cleanLine.trim();
    }

    const scene = scenes.find(s => i >= s.start && i < s.end) || scenes[scenes.length - 1];

    const bracketRegex = /\[\[\s*(.*?)\s*\]\]/gi;
    let bracketMatch;
    while ((bracketMatch = bracketRegex.exec(str)) !== null) {
      const payload = bracketMatch[1];
      for (const [name, val, numberStartInBracket, numberLength] of parsePairs(payload)) {
        const lowerName = name.toLowerCase();
        dataByChar[lowerName] = dataByChar[lowerName] || [];
        
        const numberStartInLine = bracketMatch.index + 2 + numberStartInBracket;
        
        let snippetToUse = cleanLine.replace(/\[\[.*?\]\]/g, '').trim();
        if (snippetToUse.startsWith('=')) snippetToUse = snippetToUse.substring(1).trim();
        if (!snippetToUse) snippetToUse = lastMeaningfulSnippet;
        
        dataByChar[lowerName].push({ 
          x: i - scriptStartLine,
          y: val, 
          lineIndex: i,
          markerStart: numberStartInLine,
          markerLength: numberLength,
          sceneNum: scene ? scene.num : null, 
          snippet: snippetToUse,
          originalName: name
        });
      }
    }
  }

  for (const char of Object.keys(dataByChar)) {
    dataByChar[char].sort((a, b) => a.x - b.x);
    
    if (lineStyle === "square") {
      const steppedData = [];
      for (let i = 0; i < dataByChar[char].length; i++) {
        const current = dataByChar[char][i];
        steppedData.push(current);
        
        if (i < dataByChar[char].length - 1) {
          const next = dataByChar[char][i + 1];
          steppedData.push({
            x: next.x - 0.001,
            y: current.y,
            lineIndex: current.lineIndex,
            markerStart: current.markerStart,
            markerLength: current.markerLength,
            sceneNum: current.sceneNum,
            snippet: current.snippet,
            isStepPoint: true,
            originalName: current.originalName
          });
        }
      }
      dataByChar[char] = steppedData;
    }
  }

  return { 
    dataByChar, 
    sceneMarkers, 
    sectionMarkers,
    totalLines: lines.length - scriptStartLine 
  };
}

// --- HTML / Chart.js Builder
function buildHTML(parsed, hasData = true) {
  if (!hasData) {
    return `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Emotional Journey</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
    margin: 20px;
    padding: 20px;
    background-color: #f8f9fa;
  }
  .info-box {
    background: white;
    border-radius: 8px;
    padding: 10px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 500px;
    margin: 10px auto;
  }
  h2 {
    color: #333;
    margin-top: 0;
  }
  pre {
    background: #f4f4f4;
    padding: 15px;
    border-radius: 5px;
    overflow-x: auto;
  }
</style>
</head>
<body>
  <div class="info-box">
    <h2>No emotion markers found</h2>
    <p>Use emotion markers in your script to visualize emotional journeys, use values between 0 and 100:</p>
    <pre>[[@John=30]]</pre>
    <pre>[[@Sarah=75]]</pre>
    <pre>[[@CharacterName=emotionalValue]]</pre>
    <p>You can also visualize any story attributes:</p>
    <pre>[[@Suspense=65]]</pre>
    <p>The plugin will automatically update when you add markers.</p>
  </div>
</body>
</html>`;
  }
  
  const { dataByChar, sceneMarkers, sectionMarkers, totalLines } = parsed;
  const chars = Object.keys(dataByChar);
  const palette = ["#d9534f","#337ab7","#5cb85c","#f0ad4e","#6f42c1","#20c997","#795548","#e83e8c"];

  const datasets = chars.map((name, idx) => {
    const pts = dataByChar[name].map(p => ({
      x: p.x,
      y: p.y,
      lineIndex: p.lineIndex,
      markerStart: p.markerStart,
      markerLength: p.markerLength,
      sceneNum: p.sceneNum,
      snippet: p.snippet,
      isStepPoint: p.isStepPoint || false,
      originalName: p.originalName
    }));
    const datasetLabel = capitalizeName(dataByChar[name][0]?.originalName || name);
    
    const isHidden = hiddenCharacters.has(datasetLabel);
    
    return {
      label: datasetLabel,
      data: pts,
      borderColor: palette[idx % palette.length],
      backgroundColor: 'rgba(0,0,0,0)',
      fill: false,
      tension: lineStyle === "round" ? 0.4 : 0,
      stepped: lineStyle === "square" ? 'before' : false,
      borderWidth: 3,
      pointBackgroundColor: palette[idx % palette.length],
      pointBorderWidth: 2,
      hidden: isHidden
    };
  });

  const annotationsObj = {};
  const combinedSections = combineConsecutiveSections(sectionMarkers);
  
  combinedSections.forEach((m, idx) => {
    annotationsObj["section" + idx] = {
      type: 'line',
      xMin: m.x,
      xMax: m.x,
      borderColor: 'rgba(0,0,0,0.4)',
      borderWidth: 2,
      drawTime: 'beforeDatasetsDraw'
    };
  });

  const datasetsJSON = JSON.stringify(datasets);
  const annotationsJSON = JSON.stringify(annotationsObj);
  const sectionStartsJSON = JSON.stringify(combinedSections.map(m => m.x));
  const sectionTitlesJSON = JSON.stringify(
    combinedSections.map(m => {
      if (m.title.length > 15) {
        return m.title.substring(0, 15) + '...';
      }
      return m.title;
    })
  );
  const hiddenCharsJSON = JSON.stringify(Array.from(hiddenCharacters));
  const lineStyleJSON = JSON.stringify(lineStyle);

  const scriptContent = `
    const datasets = ${datasetsJSON};
    const annotations = ${annotationsJSON};
    const sectionStarts = ${sectionStartsJSON};
    const sectionTitles = ${sectionTitlesJSON};
    const hiddenCharsFromPlugin = ${hiddenCharsJSON};
    const lineStyleFromPlugin = ${lineStyleJSON};

    let chart;
    let currentLineStyle = lineStyleFromPlugin;
    const hiddenChars = new Set(hiddenCharsFromPlugin);

    function wrapText(text, maxLineLength = 40) {
      if (!text || text.length <= maxLineLength) return [text];
      const words = text.split(' ');
      const lines = [];
      let currentLine = '';
      
      words.forEach(word => {
        if ((currentLine + word).length > maxLineLength && currentLine.length > 0) {
          lines.push(currentLine.trim());
          currentLine = word + ' ';
        } else {
          currentLine += word + ' ';
        }
      });
      
      if (currentLine.length > 0) {
        lines.push(currentLine.trim());
      }
      
      return lines;
    }

    function getResponsiveFontSize() {
      const height = window.innerHeight;
      const width = window.innerWidth;
      const area = height * width;
      
      if (area >= 800000) return { title: 14, ticks: 13, label: 16 };
      if (area >= 700000) return { title: 13, ticks: 12, label: 15 };
      if (height >= 700) return { title: 12, ticks: 11, label: 14 };
      if (height >= 500) return { title: 11, ticks: 10, label: 13 };
      if (height >= 400) return { title: 10, ticks: 9, label: 12 };
      return { title: 9, ticks: 8, label: 11 };
    }

    function getResponsiveLineAndPointSize() {
      const height = window.innerHeight;
      const width = window.innerWidth;
      const area = height * width;
      
      if (area >= 700000) return { 
        lineWidth: 4, 
        radius: 4, 
        hoverRadius: 8, 
        hitRadius: 4, 
        borderWidth: 2.5 
      };
      if (area >= 400000) return { 
        lineWidth: 3.5, 
        radius: 3.5, 
        hoverRadius: 7, 
        hitRadius: 3.5, 
        borderWidth: 2 
      };
      if (area >= 250000) return { 
        lineWidth: 3, 
        radius: 3, 
        hoverRadius: 6, 
        hitRadius: 3, 
        borderWidth: 2 
      };
      return { 
        lineWidth: 2.5, 
        radius: 2.5, 
        hoverRadius: 5, 
        hitRadius: 2.5, 
        borderWidth: 1.5 
      };
    }

    function changeLineStyle(style) {
      if (!chart || currentLineStyle === style) return;
      
      currentLineStyle = style;
      
      document.querySelectorAll('input[name="lineStyle"]').forEach(radio => {
        radio.checked = (radio.value === style);
      });
      
      chart.data.datasets.forEach(dataset => {
        dataset.stepped = style === "square" ? 'before' : false;
        dataset.tension = style === "round" ? 0.4 : 0;
        
        if (style === "square") {
          const originalDataset = datasets.find(d => d.label === dataset.label);
          if (originalDataset) {
            dataset.data = originalDataset.data;
          }
        } else {
          dataset.data = dataset.data.filter(point => !point.isStepPoint);
        }
      });
      
      chart.update('none');
      
      try {
        Beat.call('Beat.custom.updateLineStyle("' + style + '")');
      } catch (e) {
        console.log('Could not save line style setting');
      }
    }

    function toggleCharacterVisibility(character) {
      if (!chart) return;
      
      const dataset = chart.data.datasets.find(d => d.label === character);
      if (dataset) {
        dataset.hidden = !dataset.hidden;
        
        hiddenChars.clear();
        chart.data.datasets.forEach(d => {
          if (d.hidden) {
            hiddenChars.add(d.label);
          }
        });
        
        chart.update('none');
        
        try {
          Beat.call('Beat.custom.updateHiddenCharacters(' + JSON.stringify(Array.from(hiddenChars)) + ')');
        } catch (e) {
          console.log('Could not save visibility settings');
        }
      }
    }

    function updateResponsiveStyles() {
      if (!chart) return;
      
      const fontSize = getResponsiveFontSize();
      const linePointSize = getResponsiveLineAndPointSize();
      
      chart.options.scales.x.title.font.size = fontSize.title;
      chart.options.scales.x.ticks.font.size = fontSize.ticks;
      chart.options.scales.y.title.font.size = fontSize.title;
      chart.options.scales.y.ticks.font.size = fontSize.ticks;
      
      chart.data.datasets.forEach(dataset => {
        dataset.borderWidth = linePointSize.lineWidth;
      });
      
      chart.options.elements.point.radius = function(context) {
        const point = context.dataset.data[context.dataIndex];
        return point ? (point.isStepPoint ? 0 : linePointSize.radius) : 0;
      };
      
      chart.options.elements.point.hoverRadius = function(context) {
        const point = context.dataset.data[context.dataIndex];
        return point ? (point.isStepPoint ? 0 : linePointSize.hoverRadius) : 0;
      };
      
      chart.options.elements.point.hitRadius = linePointSize.hitRadius;
      
      chart.options.elements.point.borderWidth = function(context) {
        const point = context.dataset.data[context.dataIndex];
        return point ? (point.isStepPoint ? 0 : linePointSize.borderWidth) : 0;
      };
      
      chart.update('none');
    }

    const ctx = document.getElementById('emotionChart').getContext('2d');
    
    const customTicks = sectionStarts.map((start, index) => {
      return {
        value: start,
        label: sectionTitles[index]
      };
    });

    const initialFontSize = getResponsiveFontSize();
    const initialLinePointSize = getResponsiveLineAndPointSize();

    chart = new Chart(ctx, {
      type: 'line',
      data: { datasets: datasets },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        animation: { duration: 0 },
        parsing: { xAxisKey: 'x', yAxisKey: 'y' },
        interaction: {
          mode: 'point',
          intersect: true,
          includeInvisible: false
        },
        plugins: {
          legend: { 
            position: 'bottom',
            onClick: function(e, legendItem, legend) {
              toggleCharacterVisibility(legendItem.text);
            }
          },
          annotation: { annotations: annotations },
          tooltip: {
            callbacks: {
              title: (items) => {
                const p = items[0].raw;
                return p.isStepPoint ? '' : 'Scene ' + (p.sceneNum || '');
              },
              label: (ctx) => {
                const p = ctx.raw;
                return p.isStepPoint ? null : ctx.dataset.label + ': ' + p.y;
              },
              afterLabel: (ctx) => {
                const p = ctx.raw;
                if (p.isStepPoint) return null;
                
                if (p.snippet) {
                  const wrappedLines = wrapText(p.snippet, 40);
                  if (wrappedLines.length > 0) {
                    wrappedLines[0] = '→ ' + wrappedLines[0];
                  }
                  return wrappedLines;
                }
                return '';
              }
            },
            position: 'average',
            backgroundColor: 'rgba(255, 255, 255, 0.95)',
            titleColor: '#333',
            bodyColor: '#666',
            borderColor: '#ddd',
            borderWidth: 1,
            cornerRadius: 4,
            padding: 10,
            displayColors: false
          }
        },
        elements: {
          point: {
            radius: function(context) {
              const point = context.dataset.data[context.dataIndex];
              return point ? (point.isStepPoint ? 0 : initialLinePointSize.radius) : 0;
            },
            hoverRadius: function(context) {
              const point = context.dataset.data[context.dataIndex];
              return point ? (point.isStepPoint ? 0 : initialLinePointSize.hoverRadius) : 0;
            },
            hitRadius: initialLinePointSize.hitRadius,
            backgroundColor: function(context) {
              const point = context.dataset.data[context.dataIndex];
              return point ? (point.isStepPoint ? 'rgba(0,0,0,0)' : 'rgba(0,0,0,0)') : 'rgba(0,0,0,0)';
            },
            borderColor: function(context) {
              const point = context.dataset.data[context.dataIndex];
              return point ? (point.isStepPoint ? 'rgba(0,0,0,0)' : context.dataset.borderColor) : 'rgba(0,0,0,0)';
            },
            borderWidth: function(context) {
              const point = context.dataset.data[context.dataIndex];
              return point ? (point.isStepPoint ? 0 : initialLinePointSize.borderWidth) : 0;
            }
          }
        },
        onClick: (evt, activeEls) => {
          if (!activeEls || activeEls.length === 0) return;
          const first = activeEls[0];
          const ds = chart.data.datasets[first.datasetIndex];
          const pt = ds && ds.data && ds.data[first.index];
          if (!pt || pt.isStepPoint) return;

          try {
            Beat.call("Beat.custom.moveToLine(" + pt.lineIndex + ", " + pt.markerStart + ", " + pt.markerLength + ")");
          } catch (e) {
            console.error("Navigation error:", e);
          }
        },
        scales: {
          x: {
            type: 'linear',
            title: { 
              display: true, 
              text: 'Script Position',
              font: { size: initialFontSize.title }
            },
            min: 0,
            max: ${totalLines},
            ticks: {
              callback: function(value) {
                const exactMatch = customTicks.find(tick => Math.abs(tick.value - value) < 0.1);
                if (exactMatch) return exactMatch.label;
                
                let closestTick = null;
                let minDistance = Infinity;
                
                customTicks.forEach(tick => {
                  const distance = Math.abs(tick.value - value);
                  if (distance < minDistance) {
                    minDistance = distance;
                    closestTick = tick;
                  }
                });
                
                return minDistance <= 2 ? closestTick.label : '';
              },
              autoSkip: false,
              maxRotation: 45,
              minRotation: 45,
              font: { size: initialFontSize.ticks }
            },
            afterBuildTicks: function(axis) {
              axis.ticks = customTicks;
            },
            grid: {
              color: function(context) {
                const v = context.tick.value;
                return customTicks.some(tick => Math.abs(tick.value - v) < 0.1) 
                  ? 'rgba(0,0,0,0.3)' 
                  : 'rgba(0,0,0,0.1)';
              }
            }
          },
          y: {
            title: { 
              display: true, 
              text: 'Emotional Value',
              font: { size: initialFontSize.title }
            },
            min: 0,
            max: 100,
            ticks: { 
              stepSize: 10,
              font: { size: initialFontSize.ticks }
            }
          }
        }
      }
    });
    
    document.querySelectorAll('input[name="lineStyle"]').forEach(radio => {
      radio.checked = (radio.value === currentLineStyle);
    });

    window.addEventListener('resize', function() {
      if (this.resizeTimer) clearTimeout(this.resizeTimer);
      this.resizeTimer = setTimeout(() => {
        updateResponsiveStyles();
      }, 100);
    });
  `;

  return `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Emotional Journey</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@1.1.0/dist/chartjs-plugin-annotation.min.js"></script>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial;
    margin: 12px;
    height: calc(100vh - 24px);
    display: flex;
    flex-direction: column;
  }
  
  h2 {
    margin: 0 0 8px 0;
    font-size: 1.3em;
    font-weight: 600;
  }
  
  .controls-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    margin-bottom: 15px;
    flex-shrink: 0;
  }
  
  .line-style-controls {
    display: flex;
    align-items: center;
    gap: 12px;
  }
  
  .line-style-label {
    font-size: 13px;
    font-weight: 500;
    color: #555;
  }
  
  .style-options {
    display: flex;
    gap: 8px;
  }
  
  .style-option {
    display: flex;
    align-items: center;
    gap: 4px;
    cursor: pointer;
  }
  
  .style-option input {
    margin: 0;
    cursor: pointer;
  }
  
  .style-option span {
    font-size: 12px;
    color: #666;
  }
  
  #chartWrap {
    flex: 1;
    min-height: 200px;
    position: relative;
  }
  
  canvas {
    width: 100%;
    height: 100%;
  }

  .chartjs-tooltip {
    max-width: 300px;
    background: rgba(255, 255, 255, 0.95) !important;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    padding: 8px;
    font-size: 13px;
    line-height: 1.3;
  }
  
  @media (max-height: 600px) {
    body { margin: 8px; height: calc(100vh - 16px); }
    h2 { font-size: 1.1em; margin-bottom: 6px; }
    .controls-container { margin-bottom: 12px; }
    .line-style-label { font-size: 12px; }
    .style-option span { font-size: 11px; }
  }
  
  @media (max-height: 400px) {
    body { margin: 6px; height: calc(100vh - 12px); }
    h2 { font-size: 1.0em; margin-bottom: 4px; }
    .controls-container { margin-bottom: 10px; }
    .line-style-label { font-size: 11px; }
    .style-option span { font-size: 10px; }
  }

  @media (min-width: 1200px) and (min-height: 800px) {
    .line-style-label { font-size: 14px; }
    .style-option span { font-size: 13px; }
    h2 { font-size: 1.5em; }
  }
</style>
</head>
<body>
  <h2>Emotional Journey</h2>
  <div class="controls-container">
    <div class="line-style-controls">
      <span class="line-style-label">Line style:</span>
      <div class="style-options">
        <label class="style-option">
          <input type="radio" name="lineStyle" value="round" onchange="changeLineStyle('round')" ${lineStyle === 'round' ? 'checked' : ''}>
          <span>round</span>
        </label>
        <label class="style-option">
          <input type="radio" name="lineStyle" value="straight" onchange="changeLineStyle('straight')" ${lineStyle === 'straight' ? 'checked' : ''}>
          <span>straight</span>
        </label>
        <label class="style-option">
          <input type="radio" name="lineStyle" value="square" onchange="changeLineStyle('square')" ${lineStyle === 'square' ? 'checked' : ''}>
          <span>square</span>
        </label>
      </div>
    </div>
  </div>
  <div id="chartWrap"><canvas id="emotionChart"></canvas></div>
  
  <script>${scriptContent}</script>
</body>
</html>`;
}

// Start Plugin
main();